///////////////////
/* Number Theory */

// Prime operations
// Sieve of Erathosthenes O(nlogn)
vector<ll> prime;
void PrimeGenerator(ll N) {
    bool isprime[MAX + 1];
    memset(isprime, true, sizeof(isprime));
    for (ll j = 2; j <= N; j++) {
        if (isprime[j]) { 
            prime.push_back(j); 
            for (ll i = j * j; i <= N; i += j) {
                isprime[i] = false;
            }
        }
    }
}

// Linear Sieve O(n)
vector<ll> prime;
void PrimeGenerator(ll N) {
    bool isprime[MAX + 1];
    memset(isprime, true, sizeof(isprime));
    for (ll j = 2; j <= N; j++) {
        if (isprime[j]) { prime.push_back(j); }
        for (ll i = 0; i < prime.size() && j * prime[i] <= N; ++i) {
            isprime[j * prime[i]] = false;
            if (j % prime[i] == 0) break;
        }
    }
}

// Mobius Function Linear Sieve O(n)
vector<ll> prime;
ll Mobius[MAX];
void MobiusGenerator(ll N) {
    Mobius[1] = 1;
    bool isprime[MAX + 1];
    memset(isprime, true, sizeof(isprime));
    for (ll j = 2; j <= N; j++) {
        if (isprime[j]) {
            prime.push_back(j);
            Mobius[j] = -1;
        }
        for (ll i = 0; i < prime.size() && j * prime[i] <= N; ++i) {
            isprime[j * prime[i]] = false;
            if (j % prime[i] == 0) break;
            Mobius[j * prime[i]] = -Mobius[j];
        }
    }
}

// GCD && LCM

ll gcd (ll a, ll b) {
   if (a > b) { swap(a, b); }
   if (a == 0) return b;
   return gcd(b % a, a);
}
ll LCM(ll a, ll b){
	return a*b/gcd(a,b);
}

// 확장 유클리드 알고리즘
// a,b의 gcd를 구해줄 뿐만 아니라
// ax+by = gcd(a,b)의 x,y 값까지 구해준다
ll ex_gcd(ll a, ll b, ll& x, ll& y) {
    x = 1, y = 0;
    ll x1 = 0, y1 = 1, a1 = a, b1 = b;
    while (b1) {
        ll q = a1 / b1;
        tie(x, x1) = make_tuple(x1, x - q * x1);
        tie(y, y1) = make_tuple(y1, y - q * y1);
        tie(a1, b1) = make_tuple(b1, a1 - q * b1);
    }
    return a1;
}


///////////////////
/* Combinatorics */

// Catalan Numbers
A,B 각각이 n개씩 존재하고, 이들을 배열하는 방법
이때, 현재까지 배열된 상태가 항상
A가 B보다 크거나 같음을 유지하면서 2n개를 배열하는 방법이다
= 2nCn / (n+1)
= sigma Ci*Cn-i-1 from i=0 to n-1

2nCn / (n+1)을 이용하는 것이 좋아보임.

1. n개의 노드로 이루어진 이진 트리의 개수
2. n+1개의 노드로 이루어지고 루트가 있는 트리의 개수


// combination O(NlogMOD)
ll combination(ll n, ll k) {
    ll ret = 1;
    for (ll i = 1; i <= n; i++) { ret *= i; ret %= MOD; }
    ll fact = 1;
    for (ll i = 1; i <= k; i++) { fact *= i; fact %= MOD; }
    ret *= power(fact, MOD - 2); ret %= MOD;
    fact = 1;
    for (ll i = 1; i <= n - k; i++) { fact *= i; fact %= MOD; }
    ret *= power(fact, MOD - 2); ret %= MOD;
    return ret;
}

// Fibonacci Numbers O(logN)
void FibonacciMatrix(){
    Matrix table[31];
    for (int k = 0; k <= 30; k++) { table[k] = Matrix(2, 2); }
	table[0].mat[0][0] = 1; table[0].mat[0][1] = 1;
	table[0].mat[1][0] = 1; table[0].mat[1][1] = 0;

	for (int k = 1; k <= 30; k++) {
		table[k].add(table[k - 1]);
		table[k].mul(table[k - 1]);
	}
}
ll Fibonacci(int N){
    int cnt = 0;
	Matrix ans(2, 2); ans.identity();

	while (N) {
		if (N % 2) { ans.mul(table[cnt]); }

		N /= 2;		++cnt;
	}

    return ans.mat[0][1];
}


////////////////////
/* Linear Algebra */

struct Matrix {
	int r, c;
	vector<vector<ll>> mat;

	Matrix() { ; }
	Matrix(int r, int c) {
		this->r = r; this->c = c;
		mat.resize(r);
		for (int i = 0; i < r; i++) { mat[i].resize(c); }
		for (int j = 0; j < r; j++) {
			for (int i = 0; i < c; i++) { mat[j][i] = 0; }
		}
	}
	void identity() {
		for (int i = 0; i < r; i++) { mat[i][i] = 1; }
	}
	void add(Matrix& other) {
		for (int j = 0; j < r; j++) {
			for (int i = 0; i < c; i++) {
				mat[j][i] += other.mat[j][i];
				mat[j][i]%=MOD;
			}
		}
	}
	void sub(Matrix& other) {
		for (int j = 0; j < r; j++) {
			for (int i = 0; i < c; i++) {
				mat[j][i] -= other.mat[j][i];
				(mat[j][i]+MOD)%MOD;
			}
		}
	}
	void mul(Matrix& other) {
		vector<vector<ll>> ret(r);
		for (int i = 0; i < r; i++) { ret[i].resize(other.c); }

		for (int j = 0; j < r; j++) {
			for (int i = 0; i < other.c; i++) {
				for (int k = 0; k < c; k++) {
					ret[j][i] += mat[j][k] * other.mat[k][i];
					ret[j][i] %= MOD;
				}
			}
		}
		c = other.c;
		mat = ret;
	}
    void pow(ll n){
        Matrix ret(r,r), tmp(r,r);
        ret.identity();
        for (int j=0;j<r;j++){
            for (int i=0;i<c;i++){
                tmp.mat[j][i]+=mat[j][i];
            }
        }

        while(n){
            if (n&1){
                ret.mul(tmp);
            }
            tmp.mul(tmp);
            n>>=1;
        }
        mat=ret.mat;
    }

	// matrix inverse not yet
};

///////////////////
/* Discrete Math */

// Bit operations
int bitReverse(int n, int k) {
    int ret = 0;
    for (int i = 0; i < k; i++) {
        if ((n >> i) & 1) { ret |= (1 << (k - 1 - i)); }
    }
    return ret;
}
int firstbit1_pow2(int n) { // n에서 비트1인 위치를 구해서 그 수를 구함
    return n & -n;
}
int eraselast(int n) { // n에서 가장 처음으로 등장하는 비트1을 지운 수를 구함
    return n &= (n-1);
}
bool isbit0(ll n, ll m) {
    n >>= m;
    if (n & 1) { return false; }
    return true;
}
bool isbit1(ll n, ll m) {
    n >>= m;
    if (n & 1) { return true; }
    return false;
}


__popcnt(ll n) // n에서의 비트1의 개수를 세줌
_BitScanForward(ll& idx, ll n) // n에서 처음 1이 나오기까지의 0의 개수를 idx로 return한다


// power(X,Y) O(logY)
ll power(ll x, ll y) {
    if (y == 0) { return 1; }
    if (y % 2) { return power(x, y - 1) * x % MOD; }
    else {
        ll ret = power(x, y / 2);
        ret *= ret; ret %= MOD;
        return ret;
    }
}

// divide(X,Y,MOD) O(logMOD)
// MOD 소수이고 Y와 MOD가 서로소일때
ll divide(ll x, ll y, ll mod) {
    return x * power(y, mod - 2) % mod;
}

// Binary search
int lower_bound(int n){
	int lo, hi, mid;
    lo = 0; hi = N - 1;
    while (lo < hi) {
        mid = (lo + hi) / 2;
        if (a[mid]) >= n) { hi = mid; }
        else { lo = mid + 1; }
    }
	if (a[lo]==n){return n;}
	else{return -1;}
}
int upper_bound(int n){
	int lo, hi, mid;
    lo = 0; hi = N - 1;
    while (lo < hi) {
        mid = (lo + hi + 1) / 2;
        if (a[mid]) <= n) { lo = mid; }
        else { hi = mid - 1; }
    }
	if (a[lo]==n){return n;}
	else{return -1;}
}