///////////////////
/* Number Theory */


// Linear Sieve O(n)
namespace sieve{
    vector<int> gen(int N){
        vector<int> mp(N+1);
        vector<int> pr;
        for (int i=2;i<=N;i++){
            if (mp[i]==0){mp[i]=i; pr.push_back(i);}
            for (int j=0;j<pr.size() && i*pr[j]<=N; j++){
                mp[i*pr[j]] = pr[j];
                if (mp[i]==pr[j]){break;}
            }
        }
        return pr;
    }
    vector<int> get_mp(int N){
        vector<int> mp(N+1);
        vector<int> pr;
        for (int i=2;i<=N;i++){
            if (mp[i]==0){mp[i]=i; pr.push_back(i);}
            for (int j=0;j<pr.size() && i*pr[j]<=N; j++){
                mp[i*pr[j]] = pr[j];
                if (mp[i]==pr[j]){break;}
            }
        }
        return mp;
    }
}

// Euler Phi
// get : O(sqrt(N))
// gen : O(NloglogN)
namespace euler_phi{
    ll get(ll n){
        ll phi = n;
        for (ll i=2;i*i<=n;i++){
            if (n%i==0){
                while(n%i==0){n/=i;}
                phi -= phi/i;
            }
        }
        if (n>1){phi-=phi/n;}
        return phi;
    }

    vector<int> gen(int n){
        vector<int> phi(n+1);
        for (int i=1;i<=n;i++){phi[i]=i;}
        for (int j=2;j<=n;j++){
            if (phi[j]==j){
                for (int i=j;i<=n;i+=j){
                    phi[i]-=phi[i]/j;
                }
            }
        }
        return phi;
    }
}

// Miller_Rabin prime test O(logn*logn)
// check32(int) check64(ll)
// check if n is prime number 
namespace miller_rabin{
    bool check32(ll n){
        vector<int> A = {2,7,61};
        if (n==2 || n==7 || n==61){return true;}
        if (n%2==0 || n%7==0 || n%61==0){return false;}

        for (int j=0;j<3;j++){
            bool isprime=false;
            ll tmp = (n-1)/2;
            while(tmp%2==0){
                if (power(A[j],tmp,n)==n-1){isprime=true; break;}
                tmp>>=1;
            }
            ll x = power(A[j],tmp,n);
            if (x==n-1 || x==1){isprime=true;}

            if (!isprime){return false;}
        }
        return true;
    }
    bool check64(ll n){
        vector<ll> A = {2,3,5,7,11,13,17,19,23,29,31,37,41};
        if (n<=41){
            for (auto& it:A){
                if (it==n){return true;}
            }
            return false;
        }
        if (n%2==0){return false;}

        for (int j=0;j<13;j++){
            bool isprime=false;
            ll tmp = (n-1)/2;
            while(tmp%2==0){
                if (power(A[j],tmp,n)==n-1){isprime=true; break;}
                tmp>>=1;
            }
            ll x = power(A[j],tmp,n);
            if (x==n-1 || x==1){isprime=true;}

            if (!isprime){return false;}
        }
        return true;
    };
}

// Pollard Rho Factorize O(N^1/4)
// factorize(ll)
namespace pollard_rho{
    void cal(ll n, vector<ll>& v){
        if (n==1){return;}
        if (miller_rabin::check64(n)){v.push_back(n); return;}
        if (n%2==0){
            v.push_back(2);
            cal(n/2,v);
            return;
        }
        ll a,b,c,g=n;
        function<ll(ll)> f=[&](ll x){
            return ((ll128)x*x+c)%n;
        };
        while(true){
            if (g==n){
                a = b = rand()%(n-2)+2;
                c = rand()%20 + 1;
            }
            a = f(a);
            b = f(f(b));
            g = gcd(abs(a-b),n);
            if (1<g && g<n){break;}
        }
        cal(g,v);
        cal(n/g,v);
    }

    vector<ll> factorize(ll n){
        vector<ll> ret;
        cal(n,ret);
        sort(ret.begin(),ret.end());
        return ret;
    }
}

// Chinese Remainder Theorem O(sz^2)
namespace CRT{
    ll ex_gcd(ll a, ll b, ll& x, ll& y) {
        x = 1, y = 0;
        ll x1 = 0, y1 = 1, a1 = a, b1 = b;
        while (b1) {
            ll q = a1 / b1;
            tie(x, x1) = make_tuple(x1, x - q * x1);
            tie(y, y1) = make_tuple(y1, y - q * y1);
            tie(a1, b1) = make_tuple(b1, a1 - q * b1);
        }
        return a1;
    }
    ll divide(ll a, ll b, ll mod){
        ll x,y;
        ll g = ex_gcd(b,mod,x,y);
        x = (x%mod+mod)%mod;
        return a*x%mod;
    }
    ll calc(vector<ll>& a, vector<ll>& m){
        int n = a.size();
        ll M = 1;
        for (int i=0;i<n;i++){M*=m[i];}
        vector<ll> x(n);
        vector<vector<ll>> r(n,vector<ll>(n));
        for (int j=0;j<n;j++){
            for (int i=0;i<n;i++){
                r[j][i] = divide(1,m[j],m[i]);
            }
        }
        for (int j=0;j<n;j++){
            x[j]=a[j];
            for (int i=0;i<j;i++){
                x[j] = (x[j]-x[i])*r[i][j]%m[j];
                if (x[j]<0){x[j]+=m[j];}
            }
        }
        ll ans,pre; ans=0; pre=1;
        for (int i=0;i<n;i++){
            ans+=x[i]*pre%M; ans%=M;
            pre*=m[i]; pre%=M;
        }
        return ans;
    };
}

// extended Euclidean algorithm
// return gcd(a,b)
// return (x,y) of equation ax + by = gcd(a,b)
ll ex_gcd(ll a, ll b, ll& x, ll& y) {
    x = 1, y = 0;
    ll x1 = 0, y1 = 1, a1 = a, b1 = b;
    while (b1) {
        ll q = a1 / b1;
        tie(x, x1) = make_tuple(x1, x - q * x1);
        tie(y, y1) = make_tuple(y1, y - q * y1);
        tie(a1, b1) = make_tuple(b1, a1 - q * b1);
    }
    return a1;
}

// modular division
// b and mod must be relatively prime
ll divide(ll a, ll b, ll mod){
    a%=mod; b%=mod;
    ll x,y;
    ll g = ex_gcd(b,mod,x,y);
    x = (x%mod+mod)%mod;
    return a*x%mod;
}

// fast exponential
ll power(ll x, ll y, ll mod) {
    if (y == 0) { return 1; }
    if (y % 2) { return (ll128)power(x, y - 1, mod) * x % mod; }
    else {
        ll ret = power(x, y / 2, mod);
        ret = (ll128)ret*ret%mod;
        return ret;
    }
}

// Mobius Function Linear Sieve O(n)
vector<ll> prime;
ll Mobius[MAX];
void MobiusGenerator(ll N) {
    Mobius[1] = 1;
    bool isprime[MAX + 1];
    memset(isprime, true, sizeof(isprime));
    for (ll j = 2; j <= N; j++) {
        if (isprime[j]) {
            prime.push_back(j);
            Mobius[j] = -1;
        }
        for (ll i = 0; i < prime.size() && j * prime[i] <= N; ++i) {
            isprime[j * prime[i]] = false;
            if (j % prime[i] == 0) break;
            Mobius[j * prime[i]] = -Mobius[j];
        }
    }
}

///////////////////
/* Combinatorics */

// Catalan Numbers
A,B 각각이 n개씩 존재하고, 이들을 배열하는 방법
이때, 현재까지 배열된 상태가 항상
A가 B보다 크거나 같음을 유지하면서 2n개를 배열하는 방법이다
= 2nCn / (n+1)
= sigma Ci*Cn-i-1 from i=0 to n-1

2nCn / (n+1)을 이용하는 것이 좋아보임.

1. n개의 노드로 이루어진 이진 트리의 개수
2. n+1개의 노드로 이루어지고 루트가 있는 트리의 개수


// Fibonacci Numbers O(logN)
namespace fib{
    ll get(ll n){
        Matrix mat = Matrix(2,2);
        mat.mat[0]={1,1};
        mat.mat[1]={1,0};
        mat.pow(n-1);
        return mat.mat[0][0];
    }
}


////////////////////
/* Linear Algebra */

struct Matrix {
	int r, c;
	vector<vector<ll>> mat;

	Matrix() { ; }
	Matrix(int r, int c) {
		this->r = r; this->c = c;
		mat.resize(r);
		for (int i = 0; i < r; i++) { mat[i].resize(c); }
		for (int j = 0; j < r; j++) {
			for (int i = 0; i < c; i++) { mat[j][i] = 0; }
		}
	}
	void identity() {
		for (int i = 0; i < r; i++) { mat[i][i] = 1; }
	}
	void add(Matrix& other) {
		for (int j = 0; j < r; j++) {
			for (int i = 0; i < c; i++) {
				mat[j][i] += other.mat[j][i];
				mat[j][i]%=MOD;
			}
		}
	}
	void sub(Matrix& other) {
		for (int j = 0; j < r; j++) {
			for (int i = 0; i < c; i++) {
				mat[j][i] -= other.mat[j][i];
				(mat[j][i]+MOD)%MOD;
			}
		}
	}
	void mul(Matrix& other) {
		vector<vector<ll>> ret(r);
		for (int i = 0; i < r; i++) { ret[i].resize(other.c); }

		for (int j = 0; j < r; j++) {
			for (int i = 0; i < other.c; i++) {
				for (int k = 0; k < c; k++) {
					ret[j][i] += mat[j][k] * other.mat[k][i];
					ret[j][i] %= MOD;
				}
			}
		}
		c = other.c;
		mat = ret;
	}
    void pow(ll n){
        Matrix ret(r,r), tmp(r,r);
        ret.identity();
        for (int j=0;j<r;j++){
            for (int i=0;i<c;i++){
                tmp.mat[j][i]+=mat[j][i];
            }
        }

        while(n){
            if (n&1){
                ret.mul(tmp);
            }
            tmp.mul(tmp);
            n>>=1;
        }
        mat=ret.mat;
    }

	// matrix inverse not yet
};

// return basis in z2 vector set
namespace z2_basis{
    vector<ll> get_basis(ll d, vector<ll>& a){
        vector<ll> basis;
        vector<ll> mask(d);
        function<void(ll)> insert=[&](ll x){
            ll tx=x;
            for (ll b=59;b>=0;b--){
                if (tx==0){return;}
                if (tx>>b&1){
                    if (mask[b]==0){
                        mask[b]=tx;
                        basis.push_back(tx);
                        return;
                    }else{
                        tx^=mask[b];
                    }
                }
            }
        };

        for (int i=0;i<a.size();i++){insert(a[i]);}
        sort(basis.rbegin(),basis.rend());
        for (int j=1;j<basis.size();j++){
            for (int i=0;i<j;i++){
                if ((basis[i]^basis[j]) < basis[i]){basis[i]^=basis[j];}
            }
        }
        return basis;
    }
}

///////////////////
/* Discrete Math */

namespace graycode{
    int gen(int n){
        return n^(n>>1);
    }
    int inv_gen(int g){
        int ret=0;
        while(g){
            ret^=g;
            g>>=1;
        }
        return ret;
    }
}

// Bit operations
int bitReverse(int n, int k) {
    int ret = 0;
    for (int i = 0; i < k; i++) {
        if ((n >> i) & 1) { ret |= (1 << (k - 1 - i)); }
    }
    return ret;
}
int firstbit1_pow2(int n) { // n에서 비트1인 위치를 구해서 그 수를 구함
    return n & -n;
}
int eraselast(int n) { // n에서 가장 처음으로 등장하는 비트1을 지운 수를 구함
    return n &= (n-1);
}


__popcnt(ll n) // n에서의 비트1의 개수를 세줌
_BitScanForward(ll& idx, ll n) // n에서 처음 1이 나오기까지의 0의 개수를 idx로 return한다

x = 00000000 00000000 00000000 01100100
__builtin_popcount(x) = 3 : x에서 1의 개수 세줌
__builtin_clz(x) = 25 : x에서 첫번째 1 앞의 0 세줌
__builtin_ctz(x) = 2 : x에서 마지막 1 뒤의 0 세줌


// BSGS(X,Y,MOD) O(sqrtMOD*logMOD)
// X^n == Y (mod MOD)의 가장 작은 n을 찾을 때
ll BSGS(ll x, ll y, ll MOD){
    ll k = sqrt(MOD);
    map<ll,ll> mp;
    for (ll i=0;i<k;i++){
        ll div = divide(y,power(x,i,MOD),MOD);
        // mp[x]=i;
        if (mp.find(div)==mp.end()){mp[div]=i;}
    }
    for (ll i=0;i*k<MOD;i++){
        ll div = power(x,i*k,MOD);
        if (mp.find(div)!=mp.end()){
            return mp[div]+i*k;
        }
    }
    return -1;
}


// bitset (0-based)
struct bitset{
    - bit::bit<sz> st : sz짜리 bitset 초기화
    - bit::size() : size 구함
    - bit::set() : 모두 1로 세팅
    - bit::reset() : 모두 0으로 세팅
    - bit::set(x, true/false) : x원소를 0/1로 설정
    - bit::any() : 하나라도 1이면 true, 모두 0이면 false
    - bit::none() : 하나라도 1이면 false, 모두 0이면 true
    - bit::flip() : 셋 내부 모두 반전
    - bit::flip(x) : x번째 원소 반전
    - bit::test(x) : x번째 원소 0인지 1인지
    - bit::test[4], bit[4] : 배열처럼 접근 가능
    - bit::to_string() : 비트를 스트링화 시킨다
    - bit::to_ulong(), bit::to_ullong() : 비트를 ul/ull 타입으로 리턴함
}

