// Suffix Array

struct suffixarr {
    int N; string S;
    vector<int> sa, c, lcp;

    suffixarr() { N = 0; S = ""; }
    suffixarr(string _s) {
        S = _s; S.push_back('$');
        N = S.length();
        sa.resize(N);
        c.resize(N);

        vector<pair<int, int>> tmp(N), new_tmp(N);
        for (int i = 0; i < N; i++) {
            tmp[i] = { S[i],i };
        }
        vector<int> cnt(300), p(300);
        for (int i = 0; i < N; i++) {
            cnt[S[i]]++;
        }
        for (int i = 1; i < 300; i++) {
            p[i] = p[i - 1] + cnt[i - 1];
        }
        for (int i = 0; i < N; i++) {
            new_tmp[p[S[i]]] = tmp[i];
            p[S[i]]++;
        }
        swap(tmp, new_tmp);

        for (int i = 0; i < N; i++) {
            sa[i] = tmp[i].second;
        }

        c[sa[0]] = 0;
        for (int i = 1; i < N; i++) {
            if (tmp[i].first == tmp[i - 1].first) { c[sa[i]] = c[sa[i - 1]]; }
            else { c[sa[i]] = c[sa[i - 1]] + 1; }
        }

        for (ll k = 1; k < N; k <<= 1) {
            vector<pair<pair<int, int>, int>> tmp(N), new_tmp(N);
            for (int i = 0; i < N; i++) {
                tmp[i].first = { c[(sa[i] - k + N) % N],c[sa[i]] };
                tmp[i].second = (sa[i] - k + N) % N;
            }
            vector<int> cnt(N), p(N);
            for (int i = 0; i < N; i++) {
                cnt[tmp[i].first.first]++;
            }
            for (int i = 1; i < N; i++) {
                p[i] = p[i - 1] + cnt[i - 1];
                if (p[i]==N) {break;}
            }
            for (int i = 0; i < N; i++) {
                new_tmp[p[tmp[i].first.first]] = tmp[i];
                p[tmp[i].first.first]++;
            }
            swap(tmp, new_tmp);

            for (int i = 0; i < N; i++) { sa[i] = tmp[i].second; }

            c[sa[0]] = 0;
            for (int i = 1; i < N; i++) {
                if (tmp[i].first == tmp[i - 1].first) {
                    c[sa[i]] = c[sa[i - 1]];
                }
                else {
                    c[sa[i]] = c[sa[i - 1]] + 1;
                }
            }
            if (c[sa[N - 1]] == N - 1) { break; }
        }

        lcp.resize(N);
        int d = 0;
        for (int j = 0; j < N - 1; j++) {
            int x = c[j]; int i = sa[x - 1];
            while (S[j + d] == S[i + d]) { ++d; }
            lcp[x] = d;
            d = max(d - 1, 0);
        }
    }
};


// KMP Algorithm (하나의 text에서 하나의 pattern 찾을때)
// O(text + pattern)
struct KMP{
    string P;
    int pl;
    vector<int> fail;

    KMP(){pl=0;}
    KMP(string p){
        P=p; pl = P.length();
        fail.resize(pl+1);
        setfail();
    }
    void setfail() {
        fail[0] = 0;
        int i = 1, j = 0;

        while (i < pl) {
            while (j > 0 && P[i] != P[j]) { j = fail[j]; }
            if (P[i] == P[j]) { fail[++i] = ++j;}
            else { ++i; j = 0; }
        }
    }
    vector<int> query(string T){
        vector<int> ans;
        int tl = T.length();
        int i = 0, j = 0;
        while (i < tl) {
            while (j > 0 && T[i] != P[j]) { j = fail[j]; }
            if (T[i] == P[j]) { 
                ++j; ++i; 
                if (j == pl) { ans.push_back(i - pl); j = fail[j]; }
            }
            else { ++i; j = 0; }
        }
        return ans;
    }
};

// Trie (여러개의 단어에서 여러개의 단어를 찾을때)
// O(sum pattern + sum query)

struct Trie{
    int sz;
    vector<int> tmp,leaf;
    vector<vector<int>> next;

    Trie(int a){
        sz=1;
        leaf.push_back(0);
        tmp.resize(a,-1);
        next.push_back(tmp);
    }
    void add(int v, int c){
        next[v][c]=sz;
        leaf.push_back(0);
        next.push_back(tmp);
        ++sz;
    }
    void insert(string& s){
        int n = s.length();
        int cur=0;
        for (int i=0;i<n;i++){
            int c = s[i]-'a';
            if (next[cur][c]==-1){
                add(cur,c);
            }
            cur=next[cur][c];
        }
        leaf[cur]++;
    }
};


// Aho-Corasick (하나의 text에서 여러개의 패턴이 "각각 포함되어 있나" 찾아볼때)
// O(text + sum pattern)

struct ahocorasick{
    int sz;
    vector<int> par,pch,cache1,leaf,cnt,tmp;
    vector<vector<int>> next,cache2;
    ahocorasick(int a){
        sz=1;
        par.push_back(0); pch.push_back(0); cache1.push_back(0); leaf.push_back(0); cnt.push_back(0);
        tmp.resize(a,-1);
        next.push_back(tmp); cache2.push_back(tmp);
    }
    void add(int v, int c){
        next[v][c]=sz;
        par.push_back(v); pch.push_back(c); cache1.push_back(-1); leaf.push_back(0); cnt.push_back(-1);
        next.push_back(tmp); cache2.push_back(tmp);
        ++sz;
    }
    void insert(string& s){
        int n = s.length(); int cur=0;
        for (int i=0;i<n;i++){
            int c = s[i]-'a';
            if (next[cur][c]==-1){
                add(cur,c);
            }
            cur = next[cur][c];
        }
        leaf[cur]++;
    }
    int link(int v){
        if (v==0 || par[v]==0){return 0;}
        int& ret = cache1[v];
        if (ret!=-1){return ret;}
        ret = go(link(par[v]),pch[v]);
        return ret;
    }
    int go(int v, int c){
        int& ret = cache2[v][c];
        if (ret!=-1){return ret;}
        if (next[v][c]!=-1){ret = next[v][c];}
        else{
            if (v==0){ret=0;}
            else{ret = go(link(v),c);}
        }
        return ret;
    }
    int count(int v){
        if (v==0){return 0;}
        int& ret = cnt[v];
        if (ret!=-1){return ret;}
        ret = leaf[v]+count(link(v));
        return ret;
    }
};