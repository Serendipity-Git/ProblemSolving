// Suffix Array

struct SuffixA {
    ll SA[MAX], group[MAX];
    ll N, K, k;
    string S;

    SuffixA (string _S) {
        S = _S + '$'; N = S.length();
        vector<pair<char, int>> tmp(N);
        for (int i = 0; i < N; i++) { tmp[i] = { S[i],i }; }
        sort(tmp.begin(), tmp.end());
        for (int i = 0; i < N; i++) { SA[i] = tmp[i].second; }
        group[SA[0]] = 0;
        for (int i = 1; i < N; i++) {
            if (tmp[i].first == tmp[i - 1].first) { group[SA[i]] = group[SA[i - 1]]; }
            else { group[SA[i]] = group[SA[i - 1]] + 1; }
        }

        for (k = 0; (1 << k) < N; k++) {
            vector<pair<pair<int, int>, int>> vec(N), vec1(N), vec2(N);
            for (int i = 0; i < N; i++) {
                vec[i] = { {group[i],group[(i + (1 << k)) % N]},i };
            }

            vector<int> cnt1(N), cnt2(N), p1(N), p2(N);
            for (int i = 0; i < N; i++) { cnt2[vec[i].first.second]++; }
            for (int i = 1; i < N; i++) { p2[i] = p2[i - 1] + cnt2[i - 1]; }
            for (int i = 0; i < N; i++) {
                ll p = vec[i].first.second;
                vec1[p2[p]++] = vec[i];
            }

            for (int i = 0; i < N; i++) { cnt1[vec1[i].first.first]++; }
            for (int i = 1; i < N; i++) { p1[i] = p1[i - 1] + cnt1[i - 1]; }
            for (int i = 0; i < N; i++) {
                ll p = vec1[i].first.first;
                vec2[p1[p]++] = vec1[i];
            }


            for (int i = 0; i < N; i++) { SA[i] = vec2[i].second; }
            group[SA[0]] = 0;
            for (int i = 1; i < N; i++) {
                if (vec2[i].first == vec2[i - 1].first) { group[SA[i]] = group[SA[i - 1]]; }
                else { group[SA[i]] = group[SA[i - 1]] + 1; }
            }
        }
    }
};


// KMP Algorithm

string T, P;
int tl, pl;
int fail[MAX];
vector<int> ans;
void setfail() {
    fail[0] = 0;
    int i = 1, j = 0;

    while (i < pl) {
        while (j > 0 && P[i] != P[j]) { j = fail[j]; }
        if (P[i] == P[j]) { fail[++i] = ++j;}
        else { ++i; j = 0; }
    }
}
void KMP() {
    int i = 0, j = 0;
    while (i < tl) {
        while (j > 0 && T[i] != P[j]) { j = fail[j]; }
        if (T[i] == P[j]) { 
            ++j; ++i; 
            if (j == pl) { ans.push_back(i - pl); j = fail[j]; }
        }
        else { ++i; j = 0; }
    }
}