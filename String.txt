// Suffix Array

struct suffixarr {
    int N; string S;
    vector<int> sa, c, lcp;

    suffixarr() { N = 0; S = ""; }
    suffixarr(string _s) {
        S = _s; S.push_back('$');
        N = S.length();
        sa.resize(N);
        c.resize(N);

        vector<pair<int, int>> tmp(N), new_tmp(N);
        for (int i = 0; i < N; i++) {
            tmp[i] = { S[i],i };
        }
        vector<int> cnt(300), p(300);
        for (int i = 0; i < N; i++) {
            cnt[S[i]]++;
        }
        for (int i = 1; i < 300; i++) {
            p[i] = p[i - 1] + cnt[i - 1];
        }
        for (int i = 0; i < N; i++) {
            new_tmp[p[S[i]]] = tmp[i];
            p[S[i]]++;
        }
        swap(tmp, new_tmp);

        for (int i = 0; i < N; i++) {
            sa[i] = tmp[i].second;
        }

        c[sa[0]] = 0;
        for (int i = 1; i < N; i++) {
            if (tmp[i].first == tmp[i - 1].first) { c[sa[i]] = c[sa[i - 1]]; }
            else { c[sa[i]] = c[sa[i - 1]] + 1; }
        }

        for (ll k = 1; k < N; k <<= 1) {
            vector<pair<pair<int, int>, int>> tmp(N), new_tmp(N);
            for (int i = 0; i < N; i++) {
                tmp[i].first = { c[(sa[i] - k + N) % N],c[sa[i]] };
                tmp[i].second = (sa[i] - k + N) % N;
            }
            vector<int> cnt(N), p(N);
            for (int i = 0; i < N; i++) {
                cnt[tmp[i].first.first]++;
            }
            for (int i = 1; i < N; i++) {
                p[i] = p[i - 1] + cnt[i - 1];
            }
            for (int i = 0; i < N; i++) {
                new_tmp[p[tmp[i].first.first]] = tmp[i];
                p[tmp[i].first.first]++;
            }
            swap(tmp, new_tmp);

            for (int i = 0; i < N; i++) { sa[i] = tmp[i].second; }

            c[sa[0]] = 0;
            for (int i = 1; i < N; i++) {
                if (tmp[i].first == tmp[i - 1].first) {
                    c[sa[i]] = c[sa[i - 1]];
                }
                else {
                    c[sa[i]] = c[sa[i - 1]] + 1;
                }
            }
            if (c[sa[N - 1]] == N - 1) { break; }
        }

        lcp.resize(N);
        int d = 0;
        for (int j = 0; j < N - 1; j++) {
            int x = c[j]; int i = sa[x - 1];
            while (S[j + d] == S[i + d]) { ++d; }
            lcp[x] = d;
            d = max(d - 1, 0);
        }
    }
};


// KMP Algorithm

string T, P;
int tl, pl;
int fail[MAX];
vector<int> ans;
void setfail() {
    fail[0] = 0;
    int i = 1, j = 0;

    while (i < pl) {
        while (j > 0 && P[i] != P[j]) { j = fail[j]; }
        if (P[i] == P[j]) { fail[++i] = ++j;}
        else { ++i; j = 0; }
    }
}
void KMP() {
    int i = 0, j = 0;
    while (i < tl) {
        while (j > 0 && T[i] != P[j]) { j = fail[j]; }
        if (T[i] == P[j]) { 
            ++j; ++i; 
            if (j == pl) { ans.push_back(i - pl); j = fail[j]; }
        }
        else { ++i; j = 0; }
    }
}