// Suffix Array O(NlogN)
// Returned vector is of size N+1 and sa[0] = N
// LCP array contains lcp[i] = lcp(sa[i-1], sa[i]), lcp[0] = 0
// The input string must not contain any zero bytes.
struct SuffixArray{
    vi sa,lcp;
    SuffixArray(string& s, int lim = 256){
        int n = sz(s)+1, k=0, a,b;
        vi x(all(s)), y(n), ws(max(n,lim));
        x.push_back(0), sa=lcp=y, iota(all(sa),0);

        for (int j=0,p=0; p<n; j=max(1,j*2), lim=p){
            p=j, iota(all(y), n-j);
            rep(i,0,n) if (sa[i]>=j) y[p++] = sa[i]-j;
            fill(all(ws),0);
            rep(i,0,n) ws[x[i]]++;
            rep(i,1,lim) ws[i] += ws[i-1];
            for (int i=n; i--; ) sa[--ws[x[y[i]]]] = y[i];
            swap(x,y), p=1, x[sa[0]] = 0;
            for (int i=1;i<n;i++){
                a = sa[i-1], b = sa[i];
                x[b] = (y[a] == y[b] && y[a+j] == y[b+j]) ? p-1 : p++;
            }
        }

        for (int i=0,j; i<n-1; lcp[x[i++]] = k){
            for (k && k--, j = sa[x[i]-1]; s[i+k] == s[j+k]; k++);
        }
    }
};


// KMP Algorithm + Z algorithm
// linear complexity
namespace KMP{
    vector<int> getfail(const vector<int>& A){
        int N = A.size();
        vector<int> fail(N);
        fail[0]=0;
        for (int i=1;i<N;i++){
            int j = fail[i-1];
            while(j>0 && A[j]!=A[i]){j=fail[j-1];}
            if (A[j]==A[i]){fail[i]=j+1;}
        }
        return fail;
    }
    vector<int> getz(const vector<int>& A){
        int N = A.size();
        vector<int> z(N);
        int l,r; l=r=0;
        for (int i=1;i<N;i++){
            if (i<=r){z[i]=min(r-i+1,z[i-l]);}
            while(i+z[i]<N && A[z[i]]==A[i+z[i]]){++z[i];}
            if (i+z[i]-1>r){l=i; r=i+z[i]-1;}
        }
        return z;
    }
    vector<int> match(const vector<int>& T, const vector<int>& P){
        vector<int> ret;
        int N = T.size();
        int M = P.size();
        if (N<M){return ret;}
        vector<int> fail = getfail(P);
        for (int i=0,j=0; i<N;i++){
            while(j>0 && T[i]!=P[j]){
                j = fail[j-1];
            }
            if (T[i]==P[j]){
                if (j==M-1){
                    ret.push_back(i-M+1);
                    j=fail[j];
                }else{++j;}
            }
        }
        return ret;
    }
}

// Trie (여러개의 단어에서 여러개의 단어를 찾을때)
// O(sum pattern + sum query)

struct Trie{
    int sz;
    vector<int> tmp,leaf;
    vector<vector<int>> next;

    Trie(int a){
        sz=1;
        leaf.push_back(0);
        tmp.resize(a,-1);
        next.push_back(tmp);
    }
    void add(int v, int c){
        next[v][c]=sz;
        leaf.push_back(0);
        next.push_back(tmp);
        ++sz;
    }
    void insert(string& s){
        int n = s.length();
        int cur=0;
        for (int i=0;i<n;i++){
            int c = s[i]-'a';
            if (next[cur][c]==-1){
                add(cur,c);
            }
            cur=next[cur][c];
        }
        leaf[cur]++;
    }
};


// Aho-Corasick (하나의 text에서 여러개의 패턴이 "각각 포함되어 있나" 찾아볼때)
// O(text + sum pattern)

struct ahocorasick{
    int sz;
    vector<int> par,pch,cache1,leaf,cnt,tmp;
    vector<vector<int>> next,cache2;
    ahocorasick(int a){
        sz=1;
        par.push_back(0); pch.push_back(0); cache1.push_back(0); leaf.push_back(0); cnt.push_back(0);
        tmp.resize(a,-1);
        next.push_back(tmp); cache2.push_back(tmp);
    }
    void add(int v, int c){
        next[v][c]=sz;
        par.push_back(v); pch.push_back(c); cache1.push_back(-1); leaf.push_back(0); cnt.push_back(-1);
        next.push_back(tmp); cache2.push_back(tmp);
        ++sz;
    }
    void insert(string& s){
        int n = s.length(); int cur=0;
        for (int i=0;i<n;i++){
            int c = s[i]-'a';
            if (next[cur][c]==-1){
                add(cur,c);
            }
            cur = next[cur][c];
        }
        leaf[cur]++;
    }
    int link(int v){
        if (v==0 || par[v]==0){return 0;}
        int& ret = cache1[v];
        if (ret!=-1){return ret;}
        ret = go(link(par[v]),pch[v]);
        return ret;
    }
    int go(int v, int c){
        int& ret = cache2[v][c];
        if (ret!=-1){return ret;}
        if (next[v][c]!=-1){ret = next[v][c];}
        else{
            if (v==0){ret=0;}
            else{ret = go(link(v),c);}
        }
        return ret;
    }
    int count(int v){
        if (v==0){return 0;}
        int& ret = cnt[v];
        if (ret!=-1){return ret;}
        ret = leaf[v]+count(link(v));
        return ret;
    }
};


// Manacher (palindrome substring) - O(n)
namespace manacher{
    vector<int> get(string &s){
        // string -> $s#t#r#i#n#g@
        int n = s.length();
        vector<char> a(2*n+1,'#');
        vector<int> d(2*n+1);
        a[0] = '$';
        a.back() = '@';
        for (int i=0;i<n;i++){
            a[2*i+1] = s[i];
        }

        int l=1,r=2;
        for (int i=1;i<2*n;i++){
            if (i<=r){
                d[i] = min(r-i, d[l+r-i]);
            }
            while(a[i+d[i]]==a[i-d[i]]){++d[i];}
            if (i+d[i]>r){
                l = i-d[i];
                r = i+d[i];
            }
        }
        for (int i=0;i<=2*n;i++){
            if (i%2){
                if (d[i]%2==0){--d[i];}
            }else{
                if (d[i]%2){--d[i];}
            }
        }
        return d;
    }
};