// Suffix Array

struct suffixarr {
    int N; string S;
    vector<int> sa, c, lcp;

    suffixarr() { N = 0; S = ""; }
    suffixarr(string _s) {
        S = _s; S.push_back('$');
        N = S.length();
        sa.resize(N);
        c.resize(N);

        vector<pair<int, int>> tmp(N), new_tmp(N);
        for (int i = 0; i < N; i++) {
            tmp[i] = { S[i],i };
        }
        vector<int> cnt(300), p(300);
        for (int i = 0; i < N; i++) {
            cnt[S[i]]++;
        }
        for (int i = 1; i < 300; i++) {
            p[i] = p[i - 1] + cnt[i - 1];
        }
        for (int i = 0; i < N; i++) {
            new_tmp[p[S[i]]] = tmp[i];
            p[S[i]]++;
        }
        swap(tmp, new_tmp);

        for (int i = 0; i < N; i++) {
            sa[i] = tmp[i].second;
        }

        c[sa[0]] = 0;
        for (int i = 1; i < N; i++) {
            if (tmp[i].first == tmp[i - 1].first) { c[sa[i]] = c[sa[i - 1]]; }
            else { c[sa[i]] = c[sa[i - 1]] + 1; }
        }

        for (ll k = 1; k < N; k <<= 1) {
            vector<pair<pair<int, int>, int>> tmp(N), new_tmp(N);
            for (int i = 0; i < N; i++) {
                tmp[i].first = { c[(sa[i] - k + N) % N],c[sa[i]] };
                tmp[i].second = (sa[i] - k + N) % N;
            }
            vector<int> cnt(N), p(N);
            for (int i = 0; i < N; i++) {
                cnt[tmp[i].first.first]++;
            }
            for (int i = 1; i < N; i++) {
                p[i] = p[i - 1] + cnt[i - 1];
                if (p[i]==N) {break;}
            }
            for (int i = 0; i < N; i++) {
                new_tmp[p[tmp[i].first.first]] = tmp[i];
                p[tmp[i].first.first]++;
            }
            swap(tmp, new_tmp);

            for (int i = 0; i < N; i++) { sa[i] = tmp[i].second; }

            c[sa[0]] = 0;
            for (int i = 1; i < N; i++) {
                if (tmp[i].first == tmp[i - 1].first) {
                    c[sa[i]] = c[sa[i - 1]];
                }
                else {
                    c[sa[i]] = c[sa[i - 1]] + 1;
                }
            }
            if (c[sa[N - 1]] == N - 1) { break; }
        }

        lcp.resize(N);
        int d = 0;
        for (int j = 0; j < N - 1; j++) {
            int x = c[j]; int i = sa[x - 1];
            while (S[j + d] == S[i + d]) { ++d; }
            lcp[x] = d;
            d = max(d - 1, 0);
        }
    }
};


// KMP Algorithm (하나의 text에서 하나의 pattern 찾을때)
// O(text + pattern)
namespace KMP{
    template<typename T>
    vector<int> getfail(const vector<T>& A){
        int N = A.size();
        vector<int> fail(N);
        fail[0]=0;
        for (int i=1;i<N;i++){
            int j = fail[i-1];
            while(j>0 && A[j]!=A[i]){j=fail[j-1];}
            if (A[j]==A[i]){fail[i]=j+1;}
        }
        return fail;
    }

    vector<int> match(const vector<int>& text, const vector<int>& pattern){
        vector<int> ret;
        int N,M; N = text.size(); M = pattern.size();
        if (N<M){return ret;}
        vector<int> temp(N+M+1);
        for (int i=0;i<M;i++){temp[i]=pattern[i];}
        temp[M]=-1;
        for (int i=0;i<N;i++){temp[M+1+i]=text[i];}
        vector<int> fail = getfail(temp);
        for (int i=M+1;i<=M+N;i++){
            if (fail[i]==M){ret.push_back(i-2*M);}
        }
        return ret;
    }
}

// Trie (여러개의 단어에서 여러개의 단어를 찾을때)
// O(sum pattern + sum query)

struct Trie{
    int sz;
    vector<int> tmp,leaf;
    vector<vector<int>> next;

    Trie(int a){
        sz=1;
        leaf.push_back(0);
        tmp.resize(a,-1);
        next.push_back(tmp);
    }
    void add(int v, int c){
        next[v][c]=sz;
        leaf.push_back(0);
        next.push_back(tmp);
        ++sz;
    }
    void insert(string& s){
        int n = s.length();
        int cur=0;
        for (int i=0;i<n;i++){
            int c = s[i]-'a';
            if (next[cur][c]==-1){
                add(cur,c);
            }
            cur=next[cur][c];
        }
        leaf[cur]++;
    }
};


// Aho-Corasick (하나의 text에서 여러개의 패턴이 "각각 포함되어 있나" 찾아볼때)
// O(text + sum pattern)

struct ahocorasick{
    int sz;
    vector<int> par,pch,cache1,leaf,cnt,tmp;
    vector<vector<int>> next,cache2;
    ahocorasick(int a){
        sz=1;
        par.push_back(0); pch.push_back(0); cache1.push_back(0); leaf.push_back(0); cnt.push_back(0);
        tmp.resize(a,-1);
        next.push_back(tmp); cache2.push_back(tmp);
    }
    void add(int v, int c){
        next[v][c]=sz;
        par.push_back(v); pch.push_back(c); cache1.push_back(-1); leaf.push_back(0); cnt.push_back(-1);
        next.push_back(tmp); cache2.push_back(tmp);
        ++sz;
    }
    void insert(string& s){
        int n = s.length(); int cur=0;
        for (int i=0;i<n;i++){
            int c = s[i]-'a';
            if (next[cur][c]==-1){
                add(cur,c);
            }
            cur = next[cur][c];
        }
        leaf[cur]++;
    }
    int link(int v){
        if (v==0 || par[v]==0){return 0;}
        int& ret = cache1[v];
        if (ret!=-1){return ret;}
        ret = go(link(par[v]),pch[v]);
        return ret;
    }
    int go(int v, int c){
        int& ret = cache2[v][c];
        if (ret!=-1){return ret;}
        if (next[v][c]!=-1){ret = next[v][c];}
        else{
            if (v==0){ret=0;}
            else{ret = go(link(v),c);}
        }
        return ret;
    }
    int count(int v){
        if (v==0){return 0;}
        int& ret = cnt[v];
        if (ret!=-1){return ret;}
        ret = leaf[v]+count(link(v));
        return ret;
    }
};