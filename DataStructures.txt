// UnionFind (0-based)
struct DSU {
    int N;
    vector<int> parent, member;
    DSU() { N = 0; }
    DSU(int n) {
        N = n;
        parent.resize(n);
        member.resize(n);
        for (int i = 0; i < n; i++) { parent[i] = -1; member[i] = 1; }
    }
    int root(int n) {
        if (parent[n] == -1) { return n; }
        return parent[n] = root(parent[n]);
    }
    void merge(int r1, int r2) {
        r1 = root(r1);
        r2 = root(r2);
        if (r1 == r2) { return; }
        if (member[r1] < member[r2]) { swap(r1, r2); }
        parent[r2] = r1;
        member[r1] += member[r2];
    }
};


// Fenwick Tree (1-based)
// 구간의 합을 구할수 있다
struct fenwick {
    ll N;
    vector<ll> a, s, tree;
    // 사이즈 n짜리의 penwick tree를 만들어준다.
    // 1-base index 사용했다
    fenwick() { N = 0; }
    fenwick(ll n) {
        N = n;
        a.resize(n + 1);
        s.resize(n + 1);
        tree.resize(n + 1);
    }
    ll query(ll n) {
        ll ret = 0;
        while (n >= 1) {
            ret += tree[n];
            n -= (n & -n);
        }
        return ret;
    }
    // update(n,x) : n번째 원소의 값을 x로 바꿔준다
    void update(ll n, ll x) {
        ll d = x - a[n];
        a[n] += d;
        while (n <= N) {
            tree[n] += d;
            n += (n & -n);
        }
    }
    // query (l,r) : l부터 r까지의 합을 구해준다
    ll query(ll l, ll r) {
        if (l > r) { return 0; }
        return query(r) - query(l - 1);
    }
};

// Segment Tree (0-based)
// 구간 [L,R]에 관련된 쿼리를 반복적으로 처리해야 할 때 생각한다.

struct sumseg{
    int N;
    vector<ll> a,seg;
    sumseg(){N=0;}
    sumseg(int n){
        N=n;
        a.resize(N);
        seg.resize(2*N);
    }
    void init(){
        for (int i=0;i<N;i++){seg[i+N]=a[i];}
        for (int i=N-1;i>=1;i--){
            seg[i] = seg[i<<1]+seg[i<<1|1];
        }
    }
    void update(int i, ll val){
        a[i] = val;
        seg[i+N]=val;
        int p = (i+N)>>1;
        while(p>0){
            seg[p] = seg[p<<1]+seg[p<<1|1];
            p>>=1;
        }
    }
    ll query(int l, int r){
        if (l>r){return 0LL;}
        ll ret=0;
        int lp,rp;
        lp = l+N; rp=r+N+1;
        while(lp<rp){
            if (lp&1){ret+=seg[lp++];}
            if (rp&1){ret+=seg[--rp];}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};

struct maxseg{
    int N;
    vector<ll> a,seg;
    maxseg(){N=0;}
    maxseg(int n){
        N=n;
        a.resize(N);
        seg.resize(2*N);
    }
    void init(){
        for (int i=0;i<N;i++){seg[i+N]=a[i];}
        for (int i=N-1;i>=1;i--){
            seg[i] = max(seg[i<<1],seg[i<<1|1]);
        }
    }
    void update(int i, ll val){
        a[i] = val;
        seg[i+N]=val;
        int p = (i+N)>>1;
        while(p>0){
            seg[p] = max(seg[p<<1],seg[p<<1|1]);
            p>>=1;
        }
    }
    ll query(int l, int r){
        if (l>r){return -LLINF;}
        ll ret=-LLINF;
        int lp,rp;
        lp = l+N; rp=r+N+1;
        while(lp<rp){
            if (lp&1){ret=max(ret,seg[lp++]);}
            if (rp&1){ret=max(ret,seg[--rp]);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};

struct minseg{
    int N;
    vector<ll> a,seg;
    minseg(){N=0;}
    minseg(int n){
        N=n;
        a.resize(N);
        seg.resize(2*N);
    }
    void init(){
        for (int i=0;i<N;i++){seg[i+N]=a[i];}
        for (int i=N-1;i>=1;i--){
            seg[i] = min(seg[i<<1],seg[i<<1|1]);
        }
    }
    void update(int i, ll val){
        a[i] = val;
        seg[i+N]=val;
        int p = (i+N)>>1;
        while(p>0){
            seg[p] = min(seg[p<<1],seg[p<<1|1]);
            p>>=1;
        }
    }
    ll query(int l, int r){
        if (l>r){return LLINF;}
        ll ret=LLINF;
        int lp,rp;
        lp = l+N; rp=r+N+1;
        while(lp<rp){
            if (lp&1){ret=min(ret,seg[lp++]);}
            if (rp&1){ret=min(ret,seg[--rp]);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};

struct gcdseg{
    int N;
    vector<ll> a,seg;
    gcdseg(){N=0;}
    gcdseg(int n){
        N=n;
        a.resize(N);
        seg.resize(2*N);
    }
    void init(){
        for (int i=0;i<N;i++){seg[i+N]=a[i];}
        for (int i=N-1;i>=1;i--){
            seg[i] = gcd(seg[i<<1],seg[i<<1|1]);
        }
    }
    void update(int i, ll val){
        a[i] = val;
        seg[i+N]=val;
        int p = (i+N)>>1;
        while(p>0){
            seg[p] = gcd(seg[p<<1],seg[p<<1|1]);
            p>>=1;
        }
    }
    ll query(int l, int r){
        if (l>r){return 0LL;}
        ll ret=0;
        int lp,rp;
        lp = l+N; rp=r+N+1;
        while(lp<rp){
            if (lp&1){ret=gcd(ret,seg[lp++]);}
            if (rp&1){ret=gcd(ret,seg[--rp]);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};


// 2D Segment Tree (0-based)
// 2차원 직사각형 영역에 관련된 쿼리를 반복적으로 처리해야 할 때 생각한다.
// 공간 O(N*M)
// init : O(N*M)
// update : O(log*log)
// query : O(log*log)
struct sumseg2D{
    int N,M;
    vector<vector<ll>> a,seg;

    sumseg2D(){N=M=0;}
    sumseg2D(int n, int m){
        N=n; M=m;
        a.resize(N,vector<ll>(M));
        seg.resize(2*N,vector<ll>(2*M));
    }
    void init(){
        for (int j=0;j<N;j++){
            for (int i=0;i<M;i++){
                seg[j+N][i+M]=a[j][i];
            }
            for (int i=M-1;i>=1;i--){
                seg[j+N][i] = seg[j+N][i<<1]+seg[j+N][i<<1|1];
            }
        }

        for (int j=N-1;j>=1;j--){
            for (int i=1;i<2*M;i++){
                seg[j][i] = seg[j<<1][i]+seg[j<<1|1][i];
            }
        }
    }
    void update(int j, int i, ll val){
        a[j][i]=val;
        seg[j+N][i+M]=val;
        int p = (i+M)>>1;
        while(p>0){
            seg[j+N][p] = seg[j+N][p<<1]+seg[j+N][p<<1|1];
            p>>=1;
        }

        int q = (j+N)>>1;
        while(q>0){
            p = i+M;
            while(p>0){
                seg[q][p] = seg[q<<1][p]+seg[q<<1|1][p];
                p>>=1;
            }
            q>>=1;
        }
    }
    ll query1D(int q, int l, int r){
        if (l>r){return 0LL;}
        ll ret=0;
        int lp,rp;
        lp = l+M; rp=r+M+1;
        while(lp<rp){
            if (lp&1){ret+=seg[q][lp++];}
            if (rp&1){ret+=seg[q][--rp];}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
    ll query(int j1, int j2, int i1, int i2){
        if (j1>j2){return 0LL;}
        ll ret=0;
        int lp,rp;
        lp=j1+N; rp=j2+N+1;
        while(lp<rp){
            if (lp&1){ret+=query1D(lp++,i1,i2);}
            if (rp&1){ret+=query1D(--rp,i1,i2);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};

struct maxseg2D{
    int N,M;
    vector<vector<ll>> a,seg;

    maxseg2D(){N=M=0;}
    maxseg2D(int n, int m){
        N=n; M=m;
        a.resize(N,vector<ll>(M));
        seg.resize(2*N,vector<ll>(2*M));
    }
    void init(){
        for (int j=0;j<N;j++){
            for (int i=0;i<M;i++){
                seg[j+N][i+M]=a[j][i];
            }
            for (int i=M-1;i>=1;i--){
                seg[j+N][i] = max(seg[j+N][i<<1],seg[j+N][i<<1|1]);
            }
        }

        for (int j=N-1;j>=1;j--){
            for (int i=1;i<2*M;i++){
                seg[j][i] = max(seg[j<<1][i],seg[j<<1|1][i]);
            }
        }
    }
    void update(int j, int i, ll val){
        a[j][i]=val;
        seg[j+N][i+M]=val;
        int p = (i+M)>>1;
        while(p>0){
            seg[j+N][p] = max(seg[j+N][p<<1],seg[j+N][p<<1|1]);
            p>>=1;
        }

        int q = (j+N)>>1;
        while(q>0){
            p = i+M;
            while(p>0){
                seg[q][p] = max(seg[q<<1][p],seg[q<<1|1][p]);
                p>>=1;
            }
            q>>=1;
        }
    }
    ll query1D(int q, int l, int r){
        if (l>r){return -LLINF;}
        ll ret=-LLINF;
        int lp,rp;
        lp = l+M; rp=r+M+1;
        while(lp<rp){
            if (lp&1){ret=max(ret,seg[q][lp++]);}
            if (rp&1){ret=max(ret,seg[q][--rp]);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
    ll query(int j1, int j2, int i1, int i2){
        if (j1>j2){return -LLINF;}
        ll ret=-LLINF;
        int lp,rp;
        lp=j1+N; rp=j2+N+1;
        while(lp<rp){
            if (lp&1){ret=max(ret,query1D(lp++,i1,i2));}
            if (rp&1){ret=max(ret,query1D(--rp,i1,i2));}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};

struct minseg2D{
    int N,M;
    vector<vector<ll>> a,seg;

    minseg2D(){N=M=0;}
    minseg2D(int n, int m){
        N=n; M=m;
        a.resize(N,vector<ll>(M));
        seg.resize(2*N,vector<ll>(2*M));
    }
    void init(){
        for (int j=0;j<N;j++){
            for (int i=0;i<M;i++){
                seg[j+N][i+M]=a[j][i];
            }
            for (int i=M-1;i>=1;i--){
                seg[j+N][i] = min(seg[j+N][i<<1],seg[j+N][i<<1|1]);
            }
        }

        for (int j=N-1;j>=1;j--){
            for (int i=1;i<2*M;i++){
                seg[j][i] = min(seg[j<<1][i],seg[j<<1|1][i]);
            }
        }
    }
    void update(int j, int i, ll val){
        a[j][i]=val;
        seg[j+N][i+M]=val;
        int p = (i+M)>>1;
        while(p>0){
            seg[j+N][p] = min(seg[j+N][p<<1],seg[j+N][p<<1|1]);
            p>>=1;
        }

        int q = (j+N)>>1;
        while(q>0){
            p = i+M;
            while(p>0){
                seg[q][p] = min(seg[q<<1][p],seg[q<<1|1][p]);
                p>>=1;
            }
            q>>=1;
        }
    }
    ll query1D(int q, int l, int r){
        if (l>r){return LLINF;}
        ll ret=LLINF;
        int lp,rp;
        lp = l+M; rp=r+M+1;
        while(lp<rp){
            if (lp&1){ret=min(ret,seg[q][lp++]);}
            if (rp&1){ret=min(ret,seg[q][--rp]);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
    ll query(int j1, int j2, int i1, int i2){
        if (j1>j2){return LLINF;}
        ll ret=LLINF;
        int lp,rp;
        lp=j1+N; rp=j2+N+1;
        while(lp<rp){
            if (lp&1){ret=min(ret,query1D(lp++,i1,i2));}
            if (rp&1){ret=min(ret,query1D(--rp,i1,i2));}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};

struct gcdseg2D{
    int N,M;
    vector<vector<ll>> a,seg;

    gcdseg2D(){N=M=0;}
    gcdseg2D(int n, int m){
        N=n; M=m;
        a.resize(N,vector<ll>(M));
        seg.resize(2*N,vector<ll>(2*M));
    }
    void init(){
        for (int j=0;j<N;j++){
            for (int i=0;i<M;i++){
                seg[j+N][i+M]=a[j][i];
            }
            for (int i=M-1;i>=1;i--){
                seg[j+N][i] = gcd(seg[j+N][i<<1],seg[j+N][i<<1|1]);
            }
        }

        for (int j=N-1;j>=1;j--){
            for (int i=1;i<2*M;i++){
                seg[j][i] = gcd(seg[j<<1][i],seg[j<<1|1][i]);
            }
        }
    }
    void update(int j, int i, ll val){
        a[j][i]=val;
        seg[j+N][i+M]=val;
        int p = (i+M)>>1;
        while(p>0){
            seg[j+N][p] = gcd(seg[j+N][p<<1],seg[j+N][p<<1|1]);
            p>>=1;
        }

        int q = (j+N)>>1;
        while(q>0){
            p = i+M;
            while(p>0){
                seg[q][p] = gcd(seg[q<<1][p],seg[q<<1|1][p]);
                p>>=1;
            }
            q>>=1;
        }
    }
    ll query1D(int q, int l, int r){
        if (l>r){return 0;}
        ll ret=0;
        int lp,rp;
        lp = l+M; rp=r+M+1;
        while(lp<rp){
            if (lp&1){ret=gcd(ret,seg[q][lp++]);}
            if (rp&1){ret=gcd(ret,seg[q][--rp]);}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
    ll query(int j1, int j2, int i1, int i2){
        if (j1>j2){return 0;}
        ll ret=0;
        int lp,rp;
        lp=j1+N; rp=j2+N+1;
        while(lp<rp){
            if (lp&1){ret=gcd(ret,query1D(lp++,i1,i2));}
            if (rp&1){ret=gcd(ret,query1D(--rp,i1,i2));}
            lp>>=1; rp>>=1;
        }
        return ret;
    }
};


// Lazy Propagation - 세그트리 update를 할때 원소 하나만 update하는게 아니라 [L,R] 범위를 모두 update할때 쓴다
// 구간 update : O(logN)에 [L,R]을 update 할수있다.
// (1-based)


struct lazy_sumseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_sumseg() { N = 0; }
    lazy_sumseg(int n) {
        N = n; 
        int M=1;
        while(M<N){M<<=1;}
        a.resize(n + 1);
        seg.resize(M<<1);
        lazy.resize(M<<1);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = seg[node * 2] + seg[node * 2 + 1];
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] = seg[node] + lazy[node]; lazy[node] = 0; return; }
        seg[node] = seg[node] + lazy[node] * (r - l + 1);
        lazy[node * 2] = lazy[node*2] + lazy[node];
        lazy[node * 2 + 1] = lazy[node*2+1] + lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] = lazy[node] + inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = seg[node * 2] + seg[node * 2 + 1];
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return 0; }
        int mid = (l + r) >> 1;
        return query(l, mid, from, to, node * 2) + query(mid + 1, r, from, to, node * 2 + 1);
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct lazy_maxseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_maxseg() { N = 0; }
    lazy_maxseg(int n) {
        N = n; 
        int M=1;
        while(M<N){M<<=1;}
        a.resize(n + 1);
        seg.resize(M<<1);
        lazy.resize(M<<1);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = max(seg[node * 2], seg[node * 2 + 1]);
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] = seg[node] + lazy[node]; lazy[node] = 0; return; }
        seg[node] = seg[node] + lazy[node];
        lazy[node * 2] = lazy[node*2] + lazy[node];
        lazy[node * 2 + 1] = lazy[node*2+1] + lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] =lazy[node] + inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = max(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return -LLINF; }
        int mid = (l + r) >> 1;
        return max(query(l, mid, from, to, node * 2), query(mid + 1, r, from, to, node * 2 + 1));
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct lazy_minseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_minseg() { N = 0; }
    lazy_minseg(int n) {
        N = n; 
        int M=1;
        while(M<N){M<<=1;}
        a.resize(n + 1);
        seg.resize(M<<1);
        lazy.resize(M<<1);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = min(seg[node * 2], seg[node * 2 + 1]);
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] = seg[node] + lazy[node]; lazy[node] = 0; return; }
        seg[node] = seg[node] + lazy[node];
        lazy[node * 2] = lazy[node*2] + lazy[node];
        lazy[node * 2 + 1] = lazy[node*2+1] + lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] = lazy[node] + inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = min(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return LLINF; }
        int mid = (l + r) >> 1;
        return min(query(l, mid, from, to, node * 2), query(mid + 1, r, from, to, node * 2 + 1));
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct lazy_xorseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_xorseg() { N = 0; }
    lazy_xorseg(int n) {
        N = n; 
        int M=1;
        while(M<N){M<<=1;}
        a.resize(n + 1);
        seg.resize(M<<1);
        lazy.resize(M<<1);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = seg[node * 2] ^ seg[node * 2 + 1];
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] = seg[node] ^ lazy[node]; lazy[node] = 0; return; }
        if ((r - l + 1) % 2) { seg[node] = seg[node] ^ lazy[node]; }
        lazy[node * 2] = lazy[node*2] ^ lazy[node];
        lazy[node * 2 + 1] = lazy[node*2+1] ^ lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] = lazy[node] ^ inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = seg[node * 2] ^ seg[node * 2 + 1];
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return 0; }
        int mid = (l + r) >> 1;
        return query(l, mid, from, to, node * 2) ^ query(mid + 1, r, from, to, node * 2 + 1);
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};


// Sparse Table (0-based)
범위 [L,R]이 주어졌을 때 Function(L,L+1,...,R)을 빠르게 한다
조건1) Array에 저장된 값이 변하면 안된다.
조건2) Function은 결합법칙이 성립해야 한다.
-> Sparse table 만들기 O(NlogN)
-> 쿼리 1개 처리 O(logN) // O(1)

struct minsps {
    ll N;
    vector<ll> a;
    vector<vector<ll>> v;

    minsps() { N = 0; }
    minsps(ll n) {
        N = n;
        a.resize(n);
        v.resize(log2(n) + 1);
        for (int j = 0; j < v.size(); j++) {
            v[j].resize(n);
        }
    }

    void init() {
        for (int i = 0; i < N; i++) { v[0][i] = a[i]; }
        for (int k = 1; (1LL << k) < N; k++) {
            for (int i = 0; i + (1LL << (k - 1)) < N; i++) {
                v[k][i] = min(v[k - 1][i], v[k - 1][i + (1LL << (k - 1))]);
            }
        }
    }

    ll query(ll l, ll r) {
        ll D = r - l + 1;
        ll cnt = 0;
        while ((1LL << cnt) * 2 < D) {
            ++cnt;
        }
        return min(v[cnt][l], v[cnt][r + 1 - (1LL << cnt)]);
    }
};

struct maxsps {
    ll N;
    vector<ll> a;
    vector<vector<ll>> v;

    maxsps() { N = 0; }
    maxsps(ll n) {
        N = n;
        a.resize(n);
        v.resize(log2(n) + 1);
        for (int j = 0; j < v.size(); j++) {
            v[j].resize(n);
        }
    }

    void init() {
        for (int i = 0; i < N; i++) { v[0][i] = a[i]; }
        for (int k = 1; (1LL << k) < N; k++) {
            for (int i = 0; i + (1LL << (k - 1)) < N; i++) {
                v[k][i] = max(v[k - 1][i], v[k - 1][i + (1LL << (k - 1))]);
            }
        }
    }

    ll query(ll l, ll r) {
        ll D = r - l + 1;
        ll cnt = 0;
        while ((1LL << cnt) * 2 < D) {
            ++cnt;
        }
        return max(v[cnt][l], v[cnt][r + 1 - (1LL << cnt)]);
    }
};

// min-max-queue 
// queue 내의 min과 max값을 구할 수 있다.
// 나머지 push,empty,pop,front는 일반 queue 연산과 같고
// getmin, getmax 통해서 queue 내의 min,max 구할수 있다.

template <typename T>
struct minmaxqueue{
    int N;
    stack<T> s1,s2,ms1,ms2,Ms1,Ms2;

    minmaxqueue<T>(){N=0;}
    int size(){return N;}
    bool empty(){return (N==0)? true:false;}

    void push(T x){
        if (s2.empty()){ms2.push(x); Ms2.push(x);}
        else{
            if (ms2.top()>x){ms2.push(x);}
            else{ms2.push(ms2.top());}
            if (Ms2.top()<x){Ms2.push(x);}
            else{Ms2.push(Ms2.top());}
        }
        s2.push(x);
        ++N;
    };

    T front(){
        if (s1.empty()){
            while(!ms2.empty()){ms2.pop();}
            while(!Ms2.empty()){Ms2.pop();}
            while(!s2.empty()){
                T tmp = s2.top(); s2.pop();
                if (s1.empty()){ms1.push(tmp); Ms1.push(tmp);}
                else{
                    if (ms1.top()>tmp){ms1.push(tmp);}
                    else{ms1.push(ms1.top());}
                    if (Ms1.top()<tmp){Ms1.push(tmp);}
                    else{Ms1.push(Ms1.top());}
                }
                s1.push(tmp);             
            }
        }  
        T ret = s1.top();
        return ret;
    };
    void pop(){
        T tmp = front();
        s1.pop(); ms1.pop(); Ms1.pop();
        --N;
    };

    T getmin(){
        T ret;
        if (!ms1.empty() && !ms2.empty()){ret = min(ms1.top(),ms2.top());}
        else if (!ms1.empty()){ret=ms1.top();}
        else{ret=ms2.top();}
        return ret;
    };
    T getmax(){
        T ret;
        if (!Ms1.empty() && !Ms2.empty()){ret=max(Ms1.top(),Ms2.top());}
        else if (!Ms1.empty()){ret=Ms1.top();}
        else{ret=Ms2.top();}
        return ret;
    };
};


// PBDS set
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define pbds tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update>

// pbds st;
// st.insert(x) : set에 x 삽입
// st.erase(x) : set에서 x 삭제
// st.find_by_order(x) : set을 일차원 배열로 생각했을 때 x+1번째 원소 포인터 반환
// st.order_of_key(x) : set에서 x보다 작은 원소 개수 반환


// PBDS multiset
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
#define pbds tree<int, null_type, less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>
void m_erase(pbds& st, int x){
    int p = st.order_of_key(x);
    if (*st.find_by_order(p)==x){st.erase(st.find_by_order(p));}
}
// pbds st;
// st.insert(x) : multiset에 x 삽입
// m_erase(st, x) : multiset에서 x 삭제
// st.find_by_order(x) : multiset을 일차원 배열로 생각했을 때 x+1번째 원소 포인터 반환
// st.order_of_key(x) : multiset에서 x보다 작은 원소 개수 반환