// UnionFind
struct DSU {
    int N;
    vector<ll> parent, member;
    DSU() { N = 0; }
    DSU(int n) {
        N = n;
        parent.resize(n);
        member.resize(n);
        for (int i = 0; i < n; i++) { parent[i] = -1; member[i] = 1; }
    }
    int findRoot(int n) {
        if (parent[n] == -1) { return n; }
        return parent[n] = findRoot(parent[n]);
    }
    void makeUnion(int r1, int r2) {
        r1 = findRoot(r1);
        r2 = findRoot(r2);
        if (r1 == r2) { return; }
        if (member[r1] < member[r2]) { swap(r1, r2); }
        parent[r2] = r1;
        member[r1] += member[r2];
    }
};


// Penwick Tree
// 구간의 합을 구할수 있다
struct penwick {
    ll N;
    vector<ll> a, s, tree;
    // 사이즈 n짜리의 penwick tree를 만들어준다.
    // 1-base index 사용했다
    penwick(ll n) {
        N = n;
        a.resize(n + 1);
        s.resize(n + 1);
        tree.resize(n + 1);
    }
    ll sum(ll n) {
        ll ret = 0;
        while (n >= 1) {
            ret += tree[n];
            n -= (n & -n);
        }
        return ret;
    }
    // update(n,x) : n번째 원소의 값을 x로 바꿔준다
    void update(ll n, ll x) {
        ll d = x - a[n];
        a[n] += d;
        while (n <= N) {
            tree[n] += d;
            n += (n & -n);
        }
    }
    // sum(l,r) : l부터 r까지의 합을 구해준다
    ll sum(ll l, ll r) {
        return sum(r) - sum(l - 1);
    }
};

// Segment Tree
// 구간 [L,R]에 관련된 쿼리를 반복적으로 처리해야 할 때 생각한다.

struct sumseg {
    int N;
    vector<ll> a, seg;
    sumseg() { N = 0; }
    sumseg(int n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
    }

    void maketree(int left, int right, int node) {
        if (left == right) { seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        maketree(left, mid, node * 2);
        maketree(mid + 1, right, node * 2 + 1);
        seg[node] = seg[node * 2] + seg[node * 2 + 1];
    }
    void update(int left, int right, int which, ll val, int node) {
        if (left == right) { a[which] = val; seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        if (which <= mid) { update(left, mid, which, val, node * 2); }
        else { update(mid + 1, right, which, val, node * 2 + 1); }
        seg[node] = seg[node * 2] + seg[node * 2 + 1];
    }
    ll query(int left, int right, int from, int to, int node) {
        if (right<from || left>to) { return 0; }
        if (from <= left && right <= to) { return seg[node]; }
        int mid = (left + right) / 2;
        ll ret = query(left, mid, from, to, node * 2) + query(mid + 1, right, from, to, node * 2 + 1);
        return ret;
    }
    void maketree() { maketree(1, N, 1); }
    void update(int which, ll val) { update(1, N, which, val, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct gcdseg {
    ll N;
    vector<ll> a, seg;
    gcdseg() { N = 0; }
    gcdseg(ll n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
    }

    void maketree(int left, int right, int node) {
        if (left == right) { seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        maketree(left, mid, node * 2);
        maketree(mid + 1, right, node * 2 + 1);
        seg[node] = gcd(seg[node * 2], seg[node * 2 + 1]);
    }
    void update(int left, int right, int which, ll val, int node) {
        if (left == right) { a[which] = val; seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        if (which <= mid) { update(left, mid, which, val, node * 2); }
        else { update(mid + 1, right, which, val, node * 2 + 1); }
        seg[node] = gcd(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int left, int right, int from, int to, int node) {
        if (right<from || left>to) { return 0; }
        if (from <= left && right <= to) { return seg[node]; }
        int mid = (left + right) / 2;
        ll ret = gcd(query(left, mid, from, to, node * 2), query(mid + 1, right, from, to, node * 2 + 1));
        return ret;
    }
    void maketree() { maketree(1, N, 1); }
    void update(int which, ll val) { update(1, N, which, val, 1); }
    ll query(ll from, ll to) { return query(1, N, from, to, 1); }
};

struct maxseg {
    int N;
    vector<ll> a, seg;
    maxseg() { N = 0; }
    maxseg(int n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
    }

    void maketree(int left, int right, int node) {
        if (left == right) { seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        maketree(left, mid, node * 2);
        maketree(mid + 1, right, node * 2 + 1);
        seg[node] = max(seg[node * 2], seg[node * 2 + 1]);
    }
    void update(int left, int right, int which, ll val, int node) {
        if (left == right) { a[which] = val; seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        if (which <= mid) { update(left, mid, which, val, node * 2); }
        else { update(mid + 1, right, which, val, node * 2 + 1); }
        seg[node] = max(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int left, int right, int from, int to, int node) {
        if (right<from || left>to) { return -LLINF; }
        if (from <= left && right <= to) { return seg[node]; }
        int mid = (left + right) / 2;
        ll ret = max(query(left, mid, from, to, node * 2), query(mid + 1, right, from, to, node * 2 + 1));
        return ret;
    }
    void maketree() { maketree(1, N, 1); }
    void update(int which, ll val) { update(1, N, which, val, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct minseg {
    int N;
    vector<ll> a, seg;
    minseg() { N = 0; }
    minseg(int n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
    }

    void maketree(int left, int right, int node) {
        if (left == right) { seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        maketree(left, mid, node * 2);
        maketree(mid + 1, right, node * 2 + 1);
        seg[node] = min(seg[node * 2], seg[node * 2 + 1]);
    }
    void update(int left, int right, int which, ll val, int node) {
        if (left == right) { a[which] = val; seg[node] = a[left]; return; }
        int mid = (left + right) / 2;
        if (which <= mid) { update(left, mid, which, val, node * 2); }
        else { update(mid + 1, right, which, val, node * 2 + 1); }
        seg[node] = min(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int left, int right, int from, int to, int node) {
        if (right<from || left>to) { return LLINF; }
        if (from <= left && right <= to) { return seg[node]; }
        int mid = (left + right) / 2;
        ll ret = min(query(left, mid, from, to, node * 2), query(mid + 1, right, from, to, node * 2 + 1));
        return ret;
    }
    void maketree() { maketree(1, N, 1); }
    void update(int which, ll val) { update(1, N, which, val, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};


// Lazy Propagation - 세그트리 update를 할때 원소 하나만 update하는게 아니라 [L,R] 범위를 모두 update할때 쓴다
// 구간 update : O(logN)에 [L,R]을 update 할수있다.


struct lazy_sumseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_sumseg() { N = 0; }
    lazy_sumseg(int n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
        lazy.resize(4 * n + 4);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = seg[node * 2] + seg[node * 2 + 1];
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] += lazy[node]; lazy[node] = 0; return; }
        seg[node] += lazy[node] * (r - l + 1);
        lazy[node * 2] += lazy[node];
        lazy[node * 2 + 1] += lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] += inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = seg[node * 2] + seg[node * 2 + 1];
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return 0; }
        int mid = (l + r) >> 1;
        return query(l, mid, from, to, node * 2) + query(mid + 1, r, from, to, node * 2 + 1);
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct lazy_maxseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_minseg() { N = 0; }
    lazy_minseg(int n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
        lazy.resize(4 * n + 4);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = max(seg[node * 2], seg[node * 2 + 1]);
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] += lazy[node]; lazy[node] = 0; return; }
        seg[node] += lazy[node];
        lazy[node * 2] += lazy[node];
        lazy[node * 2 + 1] += lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] += inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = max(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return -LLINF; }
        int mid = (l + r) >> 1;
        return max(query(l, mid, from, to, node * 2), query(mid + 1, r, from, to, node * 2 + 1));
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};

struct lazy_minseg {
    int N;
    vector<ll> a, seg, lazy;
    lazy_minseg() { N = 0; }
    lazy_minseg(int n) {
        N = n;
        a.resize(n + 1);
        seg.resize(4 * n + 4);
        lazy.resize(4 * n + 4);
    }

    void maketree(int l, int r, int node) {
        if (l == r) { seg[node] = a[l]; return; }
        int mid = (l + r) >> 1;
        maketree(l, mid, node * 2);
        maketree(mid + 1, r, node * 2 + 1);
        seg[node] = min(seg[node * 2], seg[node * 2 + 1]);
    }
    void propagate(int l, int r, int node) {
        if (l == r) { seg[node] += lazy[node]; lazy[node] = 0; return; }
        seg[node] += lazy[node];
        lazy[node * 2] += lazy[node];
        lazy[node * 2 + 1] += lazy[node];
        lazy[node] = 0;
    }
    void update(int l, int r, int from, int to, ll inc, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { lazy[node] += inc; propagate(l, r, node); return; }
        if (from > r || to < l) { return; }
        int mid = (l + r) >> 1;
        update(l, mid, from, to, inc, node * 2);
        update(mid + 1, r, from, to, inc, node * 2 + 1);
        seg[node] = min(seg[node * 2], seg[node * 2 + 1]);
    }
    ll query(int l, int r, int from, int to, int node) {
        propagate(l, r, node);
        if (from <= l && r <= to) { return seg[node]; }
        if (from > r || to < l) { return LLINF; }
        int mid = (l + r) >> 1;
        return min(query(l, mid, from, to, node * 2), query(mid + 1, r, from, to, node * 2 + 1));
    }
    void maketree() { maketree(1, N, 1); }
    void update(int from, int to, ll inc) { update(1, N, from, to, inc, 1); }
    ll query(int from, int to) { return query(1, N, from, to, 1); }
};





// Sparse Table
범위 [L,R]이 주어졌을 때 Function(L,L+1,...,R)을 빠르게 한다
조건1) Array에 저장된 값이 변하면 안된다.
조건2) Function은 결합법칙이 성립해야 한다.

-> Sparse table 만들기 O(NlogN)
-> 쿼리 1개 처리 O(logN)
