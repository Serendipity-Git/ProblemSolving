// UnionFind
struct DSU {
    int N;
    int parent[MAX], member[MAX];
    DSU(int n) { N = n; for (int i = 0; i < N; i++) { parent[i] = -1; member[i] = 1; } }
    int findRoot(int n) {
        if (parent[n] == -1) { return n; }
        return parent[n] = findRoot(parent[n]);
    }
    void makeUnion(int r1, int r2) {
        r1 = findRoot(r1);
        r2 = findRoot(r2);
        if (r1 == r2) { return; }
        if (member[r1] < member[r2]) { swap(r1, r2); }
        parent[r2] = r1;
        member[r1] += member[r2];     
    }
};



// Penwick Tree
ll a[MAX + 1] = { 0, };
ll s[MAX + 1] = { 0, };
ll tree[MAX + 1];
ll firstbit1_pow2(ll k) { return k & -k; }
void penwick() {
    for (int i = 1; i <= N; i++) { s[i] = s[i - 1] + a[i]; }
    for (int i = 1; i <= N; i++) {
        ll p = firstbit1_pow2(i);
        tree[i] = s[i] - s[i - p];
    }
}
ll sum(ll n) {
    ll ret = 0;
    while (n >= 1) {
        ret += tree[n];
        n -= firstbit1_pow2(n);
    }
    return ret;
}
void update(ll n, ll x) {
    a[n] += x;
    while (n <= N) {
        tree[n] += x;
        n += firstbit1_pow2(n);
    }
}

// Segment Tree - 구간 [L,R]에 관련된 쿼리를 반복적으로 처리해야 할 때 생각한다.

ll A[MAX];
ll Segtree[3 * MAX];
void maketree(int left, int right, int node) {
    if (left == right) { Segtree[node] = A[left]; return; }
    int mid = (left + right) / 2;
    maketree(left, mid, node * 2);
    maketree(mid + 1, right, node * 2 + 1);
    Segtree[node] = Segtree[node * 2] + Segtree[node * 2 + 1];
}
void update(int left, int right, int which, int node) { // which에 있는 원소를 바꾸고 which에 관련된 세그트리 요소를 update한다
    if (left == right) { Segtree[node] = A[left]; return; }
    int mid = (left + right) / 2;
    if (which <= mid) { update(left, mid, which, node * 2); }
    else { update(mid + 1, right, which, node * 2 + 1); }
    Segtree[node] = Segtree[node * 2] + Segtree[node * 2 + 1];
}
ll sum(int left, int right, int from, int to, int node) { // from부터 to까지의 합을 구한다
    if (right<from || left>to) { return 0; }
    if (from <= left && right <= to) { return Segtree[node]; }
    int mid = (left + right) / 2;
    ll ret = sum(left, mid, from, to, node * 2) + sum(mid + 1, right, from, to, node * 2 + 1);
    return ret;
} 
void maketree() { maketree(1, N, 1); }
void update(ll which) { update(1, N, which, 1); }
ll sum(ll from, ll to) { return sum(1, N, from, to, 1); }


// Lazy Propagation - 세그트리 update를 할때 원소 하나만 update하는게 아니라 [L,R] 범위를 모두 update할때 쓴다
// 구간 update : O(logN)에 [L,R]을 update 할수있다.


ll A[MAX];
ll segtree[3 * MAX], lazy[3 * MAX];

void maketree(ll l, ll r, ll node) {
    if (l == r) { segtree[node] = A[l]; return; }
    ll mid = (l + r) >> 1;
    maketree(l, mid, node * 2);
    maketree(mid + 1, r, node * 2 + 1);
    segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
}
void propagate(ll l, ll r, ll node) {
    if (l == r) { segtree[node] += lazy[node]; lazy[node] = 0; return; }
    segtree[node] += lazy[node] * (r - l + 1);
    lazy[node * 2] += lazy[node];
    lazy[node * 2 + 1] += lazy[node];
    lazy[node] = 0;
}
void update(ll l, ll r, ll from, ll to, ll inc, ll node) {
    propagate(l, r, node);
    if (from <= l && r <= to) { lazy[node] += inc; propagate(l, r, node); return; }
    if (from > r || to < l) { return; }
    ll mid = (l + r) >> 1;
    update(l, mid, from, to, inc, node * 2);
    update(mid + 1, r, from, to, inc, node * 2 + 1);
    segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
}
ll sum(ll l, ll r, ll from, ll to, ll node) {
    propagate(l, r, node);
    if (from <= l && r <= to) { return segtree[node]; }
    if (from > r || to < l) { return 0; }
    ll mid = (l + r) >> 1;
    return sum(l, mid, from, to, node * 2) + sum(mid + 1, r, from, to, node * 2 + 1);
}
void maketree() { maketree(1, N, 1); }
void update(ll from, ll to, ll inc) { update(1, N, from, to, inc, 1); }
ll sum(ll from, ll to) { return sum(1, N, from, to, 1); }






// Sparse Table
범위 [L,R]이 주어졌을 때 Function(L,L+1,...,R)을 빠르게 한다
조건1) Array에 저장된 값이 변하면 안된다.
조건2) Function은 결합법칙이 성립해야 한다.

-> Sparse table 만들기 O(NlogN)
-> 쿼리 1개 처리 O(logN)
