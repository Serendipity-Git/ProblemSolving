// UnionFind
struct DSU {
    int N;
    vector<ll> parent, member;
    DSU() { N = 0; }
    DSU(int n) {
        N = n;
        parent.resize(n);
        member.resize(n);
        for (int i = 0; i < n; i++) { parent[i] = -1; member[i] = 1; }
    }
    int findRoot(int n) {
        if (parent[n] == -1) { return n; }
        return parent[n] = findRoot(parent[n]);
    }
    void makeUnion(int r1, int r2) {
        r1 = findRoot(r1);
        r2 = findRoot(r2);
        if (r1 == r2) { return; }
        if (member[r1] < member[r2]) { swap(r1, r2); }
        parent[r2] = r1;
        member[r1] += member[r2];
    }
};


// Penwick Tree
// 구간의 합을 구할수 있다
struct penwick {
    ll N;
    vector<ll> a, s, tree;
    // 사이즈 n짜리의 penwick tree를 만들어준다.
    // 1-base index 사용했다
    penwick(ll n) {
        N = n;
        a.resize(n + 1);
        s.resize(n + 1);
        tree.resize(n + 1);
    }
    ll sum(ll n) {
        ll ret = 0;
        while (n >= 1) {
            ret += tree[n];
            n -= (n & -n);
        }
        return ret;
    }
    // update(n,x) : n번째 원소의 값을 x로 바꿔준다
    void update(ll n, ll x) {
        ll d = x - a[n];
        a[n] += d;
        while (n <= N) {
            tree[n] += d;
            n += (n & -n);
        }
    }
    // sum(l,r) : l부터 r까지의 합을 구해준다
    ll sum(ll l, ll r) {
        return sum(r) - sum(l - 1);
    }
};
// Segment Tree - 구간 [L,R]에 관련된 쿼리를 반복적으로 처리해야 할 때 생각한다.

ll A[MAX];
ll Segtree[4 * MAX];
void maketree(int left, int right, int node) {
    if (left == right) { Segtree[node] = A[left]; return; }
    int mid = (left + right) / 2;
    maketree(left, mid, node * 2);
    maketree(mid + 1, right, node * 2 + 1);
    Segtree[node] = Segtree[node * 2] + Segtree[node * 2 + 1];
}
void update(int left, int right, int which, int node) { // which에 있는 원소를 바꾸고 which에 관련된 세그트리 요소를 update한다
    if (left == right) { Segtree[node] = A[left]; return; }
    int mid = (left + right) / 2;
    if (which <= mid) { update(left, mid, which, node * 2); }
    else { update(mid + 1, right, which, node * 2 + 1); }
    Segtree[node] = Segtree[node * 2] + Segtree[node * 2 + 1];
}
ll sum(int left, int right, int from, int to, int node) { // from부터 to까지의 합을 구한다
    if (right<from || left>to) { return 0; }
    if (from <= left && right <= to) { return Segtree[node]; }
    int mid = (left + right) / 2;
    ll ret = sum(left, mid, from, to, node * 2) + sum(mid + 1, right, from, to, node * 2 + 1);
    return ret;
} 
void maketree() { maketree(1, N, 1); }
void update(ll which) { update(1, N, which, 1); }
ll sum(ll from, ll to) { return sum(1, N, from, to, 1); }


// Lazy Propagation - 세그트리 update를 할때 원소 하나만 update하는게 아니라 [L,R] 범위를 모두 update할때 쓴다
// 구간 update : O(logN)에 [L,R]을 update 할수있다.


ll A[MAX];
ll segtree[4 * MAX], lazy[4 * MAX];

void maketree(ll l, ll r, ll node) {
    if (l == r) { segtree[node] = A[l]; return; }
    ll mid = (l + r) >> 1;
    maketree(l, mid, node * 2);
    maketree(mid + 1, r, node * 2 + 1);
    segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
}
void propagate(ll l, ll r, ll node) {
    if (l == r) { segtree[node] += lazy[node]; lazy[node] = 0; return; }
    segtree[node] += lazy[node] * (r - l + 1);
    lazy[node * 2] += lazy[node];
    lazy[node * 2 + 1] += lazy[node];
    lazy[node] = 0;
}
void update(ll l, ll r, ll from, ll to, ll inc, ll node) {
    propagate(l, r, node);
    if (from <= l && r <= to) { lazy[node] += inc; propagate(l, r, node); return; }
    if (from > r || to < l) { return; }
    ll mid = (l + r) >> 1;
    update(l, mid, from, to, inc, node * 2);
    update(mid + 1, r, from, to, inc, node * 2 + 1);
    segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
}
ll sum(ll l, ll r, ll from, ll to, ll node) {
    propagate(l, r, node);
    if (from <= l && r <= to) { return segtree[node]; }
    if (from > r || to < l) { return 0; }
    ll mid = (l + r) >> 1;
    return sum(l, mid, from, to, node * 2) + sum(mid + 1, r, from, to, node * 2 + 1);
}
void maketree() { maketree(1, N, 1); }
void update(ll from, ll to, ll inc) { update(1, N, from, to, inc, 1); }
ll sum(ll from, ll to) { return sum(1, N, from, to, 1); }






// Sparse Table
범위 [L,R]이 주어졌을 때 Function(L,L+1,...,R)을 빠르게 한다
조건1) Array에 저장된 값이 변하면 안된다.
조건2) Function은 결합법칙이 성립해야 한다.

-> Sparse table 만들기 O(NlogN)
-> 쿼리 1개 처리 O(logN)
