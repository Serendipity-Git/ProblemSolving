// Vector Operation
template <class T>
struct Vec{
    typedef Vec P;
    T x, y;
    explicit Vec(T x=0, T y=0) : x(x), y(y) {}
    bool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }
    bool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }
    P operator+(P p) const { return P(x+p.x, y+p.y); }
    P operator-(P p) const { return P(x-p.x, y-p.y); }
    P operator*(T d) const { return P(x*d, y*d); }
    P operator/(T d) const { return P(x/d, y/d); }
    T dot(P p) const { return x*p.x + y*p.y; }
    T cross(P p) const { return x*p.y - y*p.x; }
    T cross(P a, P b) const { return (a-*this).cross(b-*this); }
    T dist2() const { return x*x + y*y; }
    double dist() const { return sqrt((double)dist2()); }
    double angle() const { return atan2(y,x); }
    P unit() const { return *this/dist(); }
    P perp() const { return P(-y, x); }
    P normal() const { return perp().unit(); }
    P rotate(double a) const {
        return P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }
	friend ostream& operator<<(ostream& os, P p) {
		return os << "(" << p.x << "," << p.y << ")"; }
};

// 선분 교차
// requires vector
template<class T>
struct Segment{
    typedef Segment S;
    T x1,y1,x2,y2;
    explicit Segment(T x1=0,T y1=0,T x2=0,T y2=0){
        if (x1>x2 || x1==x2&&y1>y2){swap(x1,x2); swap(y1,y2);}
        this->x1 = x1;
        this->y1 = y1;
        this->x2 = x2;
        this->y2 = y2;
    }
    bool operator<(S s) const {
        if (x1==s.x1){return y1<s.y1;}
        else{return x1<s.x1;}
    }
    bool parallel (S s) const {
        Vec v1(x2-x1,y2-y1);
        Vec v2(s.x2-s.x1, s.y2-s.y1);
        if (v1.cross(v2)==0){return true;}
        else{return false;}
    }
    bool meet(S s) const {
        Vec v1(s.x1-x1, s.y1-y1);
        Vec v2(x2-x1, y2-y1);
        Vec v3(s.x2-x1, s.y2-y1);
        Vec v4(x1-s.x1, y1-s.y1);
        Vec v5(s.x2-s.x1,s.y2-s.y1);
        Vec v6(x2-s.x1,y2-s.y1);

        if (v2.cross(v1)>0&&v2.cross(v3)>0 || v2.cross(v1)<0&&v2.cross(v3)<0){return false;}
        if (v5.cross(v4)>0&&v5.cross(v6)>0 || v5.cross(v4)<0&&v5.cross(v6)<0){return false;}
        if (v2.cross(v1)==0 && v2.cross(v3)==0){
            if (x1>s.x2 || x1==s.x2&&y1>s.y2 || s.x1>x2 || s.x1==x2&&s.y1>y2){return false;}
        }
        return true;
    }
};

// linear function
// CHT에 사용되는 직선 함수 표현
// s로 직선의 시작점을 표현한다
// val로 값 계산, intersect로 다른 직선과의 교점 x좌표 계산
struct linear{
    ll m,n;
    ld s;
    linear(){;}
    linear(ll _m, ll _n, ld _s):m(_m),n(_n),s(_s){}
    ll val(ll x){return m*x+n;}
    ld intersect(const linear& l){
        return (ld)(l.n-n)/(m-l.m);
    }
};

// point
template<typename T>
struct pt{
    T x,y;
    pt(){x=y=0;}
    pt(T _x, T _y){
        x=_x; y=_y;
    }
};

// Convex Hull (NlogN)
// include_colinear variable로 같은 직선 위의 점들을 모두 포함할 것인지 선택가능하다.
// query함수로 convex hull을 이루는 실제 점들을 pt배열로 리턴한다 (0-based)
// requires point
template<typename T>
struct convexhull{
    int sz;
    bool include_colinear;
    vector<pt<T>> v;

    convexhull(){sz=0; include_colinear=false;}
    convexhull(int n, bool co=false){
        sz=n;
        v.resize(n);
        include_colinear = co;
    }
    int orientation(pt<T>& a, pt<T>& b, pt<T>& c){
        T ret = a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y);
        if (ret<0){return -1;}
        else if (ret>0){return 1;}
        else{return 0;}
    };
    bool ccw(pt<T>& a, pt<T>& b, pt<T>& c, bool include_colinear=false){
        int o = orientation(a,b,c);
        return o>0 || (include_colinear&&o==0);
    };
    bool colinear(pt<T>& a, pt<T>& b, pt<T>& c){
        return orientation(a,b,c)==0;
    };

    vector<pt<T>> query(){
        vector<pt<T>> ret;
        pt<T> p0 = *min_element(v.begin(),v.end(),[&](pt<T>&a, pt<T>&b){
            return make_pair(a.y,a.x)<make_pair(b.y,b.x);
        });

        sort(v.begin(),v.end(),[&](pt<T>&a, pt<T>&b){
            T o = orientation(p0,a,b);
            if (o==0){
                return (p0.x-a.x)*(p0.x-a.x)+(p0.y-a.y)*(p0.y-a.y)<(p0.x-b.x)*(p0.x-b.x)+(p0.y-b.y)*(p0.y-b.y);
            }else{
                return o>0;
            }
        });
        if (include_colinear){
            int i = sz-1;
            while(i>=0 && colinear(p0,v.back(),v[i])){--i;}
            reverse(v.begin()+i+1,v.end());
        }

        for (int i=0;i<sz;i++){
            while(ret.size()>1 && !ccw(ret[ret.size()-2], ret[ret.size()-1],v[i], include_colinear)){ret.pop_back();}
            ret.push_back(v[i]);
        }

        return ret;
    };
};


// Rotating Calipers (NlogN)
// requires point,vector,convexhull
// poly.v에 점들을 넣고 init으로 convexhull 설정
// query를 통해 {거리, {i,j}} 구할 수 있음 (0-based)

template<typename T>
struct calipers{
    int sz;
    convexhull<T> poly;
    vector<pt<T>> hull;

    calipers(){sz=0;}
    calipers(int N){
        sz=N;
        poly = convexhull<T>(sz);
    }
    void init(){
        hull = poly.query();
        sz = hull.size();
    }
    pair<ld,pi> query(){
        pair<ld,pi> ans={-1,{-1,-1}};
        int j=1;
        for (int i=0;i<sz;i++){
            while(true){
                ld dis = sqrt((hull[i].x-hull[j].x)*(hull[i].x-hull[j].x) + (hull[i].y-hull[j].y)*(hull[i].y-hull[j].y));
                ans = max(ans, {dis,{i,j}});
                vec<ll> v1 = vec<ll>(hull[(i+1)%sz].x-hull[i].x, hull[(i+1)%sz].y-hull[i].y);
                vec<ll> v2 = vec<ll>(hull[(j+1)%sz].x-hull[j].x, hull[(j+1)%sz].y-hull[j].y);
                if (v1.cross(v2)<=0){break;}
                j = (j+1)%sz;
            }
        }
        return ans;
    }
};
