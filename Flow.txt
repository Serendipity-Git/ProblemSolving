// Dinic algorithm O(V^2*E)
// 0-based이다
// 단방향 그래프이다

// fast version
struct maxflow{
    struct Edge{
        int u,v,rev=0;
        ll c,f=0;
        Edge(int u, int v, ll c) : u(u), v(v), c(c){}
        ll spare() { return c - f; }
    };
    
    int N,s,t;
    vector<vector<Edge>> adj;
    vector<int> level,see;
    queue<int> que;

    maxflow(){N=s=t=0;}
    maxflow(int n, int s, int t):N(n),s(s),t(t){
        level.resize(N);
        see.resize(N);
        adj.resize(N);
    }
    void add(Edge& e, ll inc) {
        e.f+=inc;
        adj[e.v][e.rev].f-=inc;
    }
    void addEdge(int u, int v, ll c, bool undirected = 0) {
        Edge e1 = Edge(u,v,c);
        if (undirected){
            Edge e2 = Edge(v,u,c);
            e1.rev = adj[v].size();
            e2.rev = adj[u].size();
            adj[u].push_back(e1);
            adj[v].push_back(e2);
        }
        else{
            Edge e2 = Edge(v,u,0);
            e1.rev = adj[v].size();
            e2.rev = adj[u].size();
            adj[u].push_back(e1);
            adj[v].push_back(e2);
        }
    }
    bool bfs() {
        for (int i=0;i<N;i++){level[i]=-1;}
        level[s] = 0; que.push(s);
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            for (auto& it : adj[cur]) {
                ll sp = it.spare();
                if (sp > 0 && level[it.v] == -1) {
                    que.push(it.v); level[it.v] = level[cur] + 1;
                }
            }
        }
        if (level[t] == -1) { return false; }
        return true;
    }
    ll dfs(int n, ll flow) {
        if (n == t) { return flow; }
        for (int& i = see[n]; i < (int)adj[n].size(); i++) {
            Edge& e = adj[n][i];
            int next = e.v;
            ll sp = e.spare();
            if (sp > 0 && level[next] == level[n] + 1) {
                ll f = dfs(next, min(flow, sp));
                if (f > 0) { add(e,f); return f; }
            }
        }
        return 0;
    }
    ll query() {
        ll ret = 0;
        while (bfs()) {
            for (int i=0;i<N;i++){see[i]=0;}
            while (true) {
                ll f = dfs(s, LLINF);
                if (f == 0) { break; }
                ret += f;
            }
        }
        return ret;
    }
};

// easy version
struct maxflow{
    struct edge{
        int u,v;
        ll c,f=0;
        edge(int u, int v, ll c):u(u),v(v),c(c){}

    };

    int N,s,t,M=0;
    vector<edge> E;
    vector<int> level,see;
    vector<vector<int>> adj;
    queue<int> que;

    maxflow(int N, int s, int t):N(N),s(s),t(t){
        level.resize(N); see.resize(N); adj.resize(N);
    }

    void addEdge(int u, int v, ll c, bool undirected=0){
        if (undirected){
            E.emplace_back(u,v,c);
            E.emplace_back(v,u,c);
        }else{
            E.emplace_back(u,v,c);
            E.emplace_back(v,u,0);
        }
        adj[u].push_back(M);
        adj[v].push_back(M+1);
        M+=2;
    }
    bool bfs(){
        fill(level.begin(),level.end(),-1);
        que.push(s); level[s]=0;
        while(!que.empty()){
            int u = que.front(); que.pop();
            for (int& e:adj[u]){
                int v = E[e].v;
                if (E[e].c-E[e].f>0 && level[v]==-1){
                    level[v] = level[u]+1; que.push(v);
                }
            }
        }
        return (level[t]!=-1);
    }
    ll dfs(int u, ll flow){
        if (u==t){return flow;}
        if (flow==0){return 0;}

        for (int& i=see[u]; i<(int)adj[u].size();i++){
            int e = adj[u][i];
            ll sp = E[e].c - E[e].f;
            int v = E[e].v;
            if (sp>0 && level[v]==level[u]+1){
                ll f = dfs(v,min(flow,sp));
                if (f>0){
                    E[e].f+=f;
                    E[e^1].f-=f;
                    return f;
                }
            }
        }
        return 0;
    }
    ll query(){
        ll ans=0;
        while(bfs()){
            fill(see.begin(),see.end(),0);
            while(ll flow = dfs(s,LLINF)){
                ans+=flow;
            }
        }
        return ans;
    }
};

// Konig's theorem
// vertex cover : subset of vertex S -> 모든 간선의 양 끝점 중 하나가 S에 포함됨
// independent set : subset of vertex S -> S에 속한 점끼리 edge가 존재하지 않음
// matching : subset of edge E -> E끼리는 인접하지 않음

// Konig's Theorem : In bigraph, |minimum vertex cover| = |maximum matching|
// How ? Find min-cut in bigraph, then (unreachable in A + reachable in B) = vertex cover = |min-cut|
// independent set = { U - vertex cover }


// MaxFlow - MinCost O(V*E*F)~O(E*F)
// 0-based이다
// 단방향이다
// edge의 cost까지도 추가해줘야 한다

// fast version
struct MCMF{
    struct Edge {
        int to,rev;
        ll cap, flow, cost;
        Edge(){to=rev=cap=flow=cost=0;}
        Edge(int _to, ll _cap, ll _cost) :to(_to), cap(_cap), cost(_cost), flow(0) {}
        ll spare() { return cap - flow; }
    };
	int N,s,t;
	vector<vector<Edge>> adj;

	MCMF(){N=s=t=0;}
	MCMF(int _n, int _s, int _t){
		N=_n; s=_s; t=_t;
		adj.resize(N);
	}
    void add(Edge& e, ll inc) {
        e.flow+=inc;
        adj[e.to][e.rev].flow-=inc;
    }
	void addEdge(int u, int v, ll cap, ll cost) {
        Edge e1 = Edge(v,cap,cost);
        Edge e2 = Edge(u,0,-cost);
        e1.rev = adj[v].size();
        e2.rev = adj[u].size();
        adj[u].push_back(e1);
        adj[v].push_back(e2);
	}

	pair<ll, ll> query() {
		pii ret;
		ll cans = 0, fans = 0;
		while (true) {
			vector<ll> dis(N,LLINF);
			vector<int> prev(N,-1);
			vector<bool> inque(N);
			vector<Edge*> path(N);
			queue<int> que;

			que.push(s); inque[s] = true; dis[s] = 0;
			while (!que.empty()) {
				int cur = que.front(); que.pop(); inque[cur] = false;
				for (auto& it : adj[cur]) {
					if (it.spare() > 0 && dis[it.to] > dis[cur] + it.cost) {
						if (!inque[it.to]) { que.push(it.to); inque[it.to] = true; }
						dis[it.to] = dis[cur] + it.cost;
						prev[it.to] = cur;
						path[it.to] = &it;
					}
				}
			}
			if (prev[t] == -1) { break; }
			ll flow = INF;
			for (ll i = t; i != s; i = prev[i]) {
				flow = min(flow, path[i]->spare());
			}
			fans += flow;
			for (ll i = t; i != s; i = prev[i]) {
				cans += path[i]->cost;
				add(*path[i],fans);
			}
		}
		ret.first = fans;
		ret.second = cans;
		return ret;
	}
};

// easy version
struct mcmf{
    struct edge{
        int u,v;
        ll c,f=0,w;
        edge(int u, int v, ll c, ll w):u(u),v(v),c(c),w(w){}
    };

    int N,s,t,M=0;
    vector<edge> E;
    vector<int> vis;
    vector<ll> dis,flow;
    vector<vector<int>> adj;
    queue<int> que;

    mcmf(int N, int s, int t):N(N),s(s),t(t){
        adj.resize(N);
        vis.resize(N);
        dis.resize(N);
        flow.resize(N);
    }

    void addEdge(int u, int v, ll c, ll w){
        E.emplace_back(u,v,c,w);
        E.emplace_back(v,u,0,-w);
        adj[u].push_back(M);
        adj[v].push_back(M+1);
        M+=2;
    }
    pii spfa(){
        fill(flow.begin(),flow.end(),LLINF);
        fill(dis.begin(),dis.end(),LLINF);
        fill(vis.begin(),vis.end(),-1);
        que.push(s); dis[s]=0;
        while(!que.empty()){
            int u = que.front(); que.pop();
            for (int& e:adj[u]){
                int v = E[e].v;
                ll w = E[e].w;
                ll sp = E[e].c - E[e].f;
                if (sp>0 && dis[v]>dis[u]+w){
                    dis[v] = dis[u]+w;
                    vis[v] = e;
                    flow[v] = min(sp,flow[u]);
                    que.push(v);
                }
            }
        }
        if (vis[t]==-1){return {0,0};}
        if (flow[t]==0){return {0,0};}

        int v = t;
        ll fret = flow[t];
        ll wret = 0;
        while(v!=s){
            int e = vis[v];
            int u = E[e].u;
            ll w = E[e].w;
            wret+=w*fret;
            E[e].f+=fret;
            E[e^1].f-=fret;
            v = u;
        }
        return {fret,wret};
    }
    pii query(){
        pii ans={0,0};
        while(true){
            pii ret = spfa();
            ll f,w; f=ret.first; w=ret.second;
            ans.first+=f; ans.second+=w;
            if (f==0){break;}
        }
        return ans;
    }
};


// Circulation by Dinic O(V^2*E)
// addEdge(u,v,l,r)로 edge 추가
// maxflow > graph.sum이면 가능한 flow가 없는 것이다.
// 설계한 circulation graph의 edge를 모두 설정하고 init()으로 circulation graph를 만든다
// 가능한 flow가 존재한다면, E[e].l + E[e].f로 e에 흐르는 실제 flow를 구할 수 있다.

struct circulation{
    struct edge{
        int u,v;
        ll c,l,f=0;
        edge(int u, int v, ll c, ll l):u(u),v(v),c(c),l(l){}
    };

    int N,s,t,s_,t_,M=0;
    ll sum=0;
    vector<ll> d;
    vector<int> level,see;
    vector<vector<int>> adj;
    vector<edge> E;
    queue<int> que;

    circulation(int N, int s, int t, int s_, int t_):N(N),s(s),t(t),s_(s_), t_(t_){
        level.resize(N); see.resize(N); d.resize(N);
        adj.resize(N);
    }
    void addEdge(int u, int v, ll l, ll r){
        d[u]+=l;
        d[v]-=l;
        E.emplace_back(u,v,r-l,l);
        E.emplace_back(v,u,0,0);
        adj[u].push_back(M);
        adj[v].push_back(M+1);
        M+=2;
    }
    void init(){
        for (int i=0;i<N;i++){
            if (i==s_ || i==t_){continue;}
            if (d[i]>0){
                addEdge(i,t_,0,d[i]);
                sum+=d[i];
            }else if (d[i]<0){
                addEdge(s_,i,0,-d[i]);
            }
        }
    }
    bool bfs(){
        fill(level.begin(),level.end(),-1);
        level[s_]=0; que.push(s_);
        while(!que.empty()){
            int u = que.front(); que.pop();
            for (int e:adj[u]){
                int v = E[e].v;
                ll sp = E[e].c - E[e].f;
                if (sp>0 && level[v]==-1){
                    level[v]=level[u]+1;
                    que.push(v);
                }
            }
        }
        return (level[t_]!=-1);
    }
    ll dfs(int u ,ll flow){
        if (u==t_){return flow;}
        if (flow==0){return 0;}

        for (int& i=see[u]; i<(int)adj[u].size();i++){
            int e = adj[u][i];
            ll sp = E[e].c - E[e].f;
            int v = E[e].v;
            if (sp>0 && level[v]==level[u]+1){
                ll f = dfs(v,min(flow,sp));
                if (f>0){
                    E[e].f+=f;
                    E[e^1].f-=f;
                    return f;
                }
            }
        }
        return 0;
    }
    ll query(){
        ll ans = 0;
        while(bfs()){
            fill(see.begin(),see.end(),0);
            while(ll f = dfs(s_,LLINF)){
                ans+=f;
            }
        }   
        return ans;
    }
};


// Blossom Algorithm O(VE)
// maximum matching in general graph
vector<int> Blossom(vector<vector<int>>& graph) {
    int n = graph.size(), timer = -1;
    vector<int> mate(n, -1), label(n), parent(n), 
                orig(n), aux(n, -1), q;
    auto lca = [&](int x, int y) {
        for (timer++; ; swap(x, y)) {
        if (x == -1) continue;
        if (aux[x] == timer) return x;
        aux[x] = timer;
        x = (mate[x] == -1 ? -1 : orig[parent[mate[x]]]);
        }
    };
    auto blossom = [&](int v, int w, int a) {
        while (orig[v] != a) {
        parent[v] = w; w = mate[v];
        if (label[w] == 1) label[w] = 0, q.push_back(w);
        orig[v] = orig[w] = a; v = parent[w];
        }
    };
    auto augment = [&](int v) {
        while (v != -1) {
        int pv = parent[v], nv = mate[pv];
        mate[v] = pv; mate[pv] = v; v = nv;
        }
    };
    auto bfs = [&](int root) {
        fill(label.begin(), label.end(), -1);
        iota(orig.begin(), orig.end(), 0);
        q.clear(); 
        label[root] = 0; q.push_back(root);
        for (int i = 0; i < (int)q.size(); ++i) {
        int v = q[i];
        for (auto x : graph[v]) {
            if (label[x] == -1) {
            label[x] = 1; parent[x] = v;
            if (mate[x] == -1) 
                return augment(x), 1;
            label[mate[x]] = 0; q.push_back(mate[x]);
            } else if (label[x] == 0 && orig[v] != orig[x]) {
            int a = lca(orig[v], orig[x]);
            blossom(x, v, a); blossom(v, x, a);
            }
        }
        }
        return 0;
    };
    // Time halves if you start with (any) maximal matching.
    for (int i = 0; i < n; i++) 
        if (mate[i] == -1) 
        bfs(i);
    return mate;
}