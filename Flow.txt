// Dinic algorithm O(V^2*E)
// 0-based이다
// 단방향 그래프이다

struct maxflow{
    struct Edge{
        int to,rev;
        ll c,f;
        Edge(int _to, ll _c) : to(_to), c(_c), f(0) {}
        ll spare() { return c - f; }
    };
    
    int N,s,t;
    vector<vector<Edge>> adj;
    vector<int> level,see;
    queue<int> que;

    maxflow(){N=s=t=0;}
    maxflow(int n, int _s, int _t){
        N=n;s=_s;t=_t;
        adj.resize(N);
        level.resize(N);
        see.resize(N);
    }
    void add(Edge& e, ll inc) {
        e.f+=inc;
        adj[e.to][e.rev].f-=inc;
    }
    void addEdge(int u, int v, ll c, bool undirected = 0) {
        Edge e1 = Edge(v,c);
        if (undirected){
            Edge e2 = Edge(u,c);
            e1.rev = adj[v].size();
            e2.rev = adj[u].size();
            adj[u].push_back(e1);
            adj[v].push_back(e2);
        }
        else{
            Edge e2 = Edge(u,0);
            e1.rev = adj[v].size();
            e2.rev = adj[u].size();
            adj[u].push_back(e1);
            adj[v].push_back(e2);
        }
    }
    bool bfs() {
        for (int i=0;i<N;i++){level[i]=-1;}
        level[s] = 0; que.push(s);
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            for (auto& it : adj[cur]) {
                ll sp = it.spare();
                if (sp > 0 && level[it.to] == -1) {
                    que.push(it.to); level[it.to] = level[cur] + 1;
                }
            }
        }
        if (level[t] == -1) { return false; }
        return true;
    }
    ll dfs(int n, ll flow) {
        if (n == t) { return flow; }
        for (int& i = see[n]; i < (int)adj[n].size(); i++) {
            Edge& e = adj[n][i];
            int next = e.to;
            ll sp = e.spare();
            if (sp > 0 && level[next] == level[n] + 1) {
                ll f = dfs(next, min(flow, sp));
                if (f > 0) { add(e,f); return f; }
            }
        }
        return 0;
    }
    ll query() {
        ll ret = 0;
        while (bfs()) {
            for (int i=0;i<N;i++){see[i]=0;}
            while (true) {
                ll f = dfs(s, INF);
                if (f == 0) { break; }
                ret += f;
            }
        }
        return ret;
    }
};

// Hopcroft-Karp O(E*sqrt(V))
// 0-based이다
// 양방향이다
// L->R로만 edge를 추가해주면 된다

struct bimatch{
    int N,M;
    vector<int> L,R,level,see;
    vector<vector<int>> adj;
    queue<int> que;

    bimatch(){N=M=0;}
    bimatch(int n, int m){
        N=n; M=m;
        L.resize(N); R.resize(M);
        level.resize(N); see.resize(N);
        adj.resize(N);
    }
    void addEdge(int u, int v){
        adj[u].push_back(v);
    }
    bool dfs(int n) {
        for (; see[n] < adj[n].size(); see[n]++) {
            int it = adj[n][see[n]];
            if (R[it] == -1 || level[R[it]] == level[n] + 1 && dfs(R[it])) {
                L[n] = it;
                R[it] = n;
                return true;
            }
        }
        return false;
    }
    void bfs() {
        for (int i = 0; i < N; i++) {
            if (L[i] == -1) { que.push(i); level[i] = 0; }
            else { level[i] = INF; }
            see[i] = 0;
        }
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            for (auto it : adj[cur]) {
                if (R[it] != -1 && level[R[it]] == INF) {
                    que.push(R[it]); level[R[it]] = level[cur] + 1;
                }
            }
        }
    }
    ll query() {
        ll ret = 0;
        for (int i=0;i<N;i++){L[i]=-1;}
        for (int i=0;i<M;i++){R[i]=-1;}
        while (true) {
            bfs();
            ll flow = 0;
            for (int i = 0; i < N; i++) {
                if (L[i] == -1 && dfs(i)) { ++flow; }
            }
            if (flow == 0) { break; }
            ret += flow;
        }
        return ret;
    }
};


// MaxFlow - MinCost O(V*E*F)~O(E*F)
// 0-based이다
// 단방향이다
// edge의 cost까지도 추가해줘야 한다

struct MCMF{
    struct Edge {
        int to,rev;
        ll cap, flow, cost;
        Edge(){to=rev=cap=flow=cost=0;}
        Edge(int _to, ll _cap, ll _cost) :to(_to), cap(_cap), cost(_cost), flow(0) {}
        ll spare() { return cap - flow; }
    };
	int N,s,t;
	vector<vector<Edge>> adj;

	MCMF(){N=s=t=0;}
	MCMF(int _n, int _s, int _t){
		N=_n; s=_s; t=_t;
		adj.resize(N);
	}
    void add(Edge& e, ll inc) {
        e.flow+=inc;
        adj[e.to][e.rev].flow-=inc;
    }
	void addEdge(int u, int v, ll cap, ll cost) {
        Edge e1 = Edge(v,cap,cost);
        Edge e2 = Edge(u,0,-cost);
        e1.rev = adj[v].size();
        e2.rev = adj[u].size();
        adj[u].push_back(e1);
        adj[v].push_back(e2);
	}

	pair<ll, ll> query() {
		pii ret;
		ll cans = 0, fans = 0;
		while (true) {
			vector<ll> dis(N,LLINF);
			vector<int> prev(N,-1);
			vector<bool> inque(N);
			vector<Edge*> path(N);
			queue<int> que;

			que.push(s); inque[s] = true; dis[s] = 0;
			while (!que.empty()) {
				int cur = que.front(); que.pop(); inque[cur] = false;
				for (auto& it : adj[cur]) {
					if (it.spare() > 0 && dis[it.to] > dis[cur] + it.cost) {
						if (!inque[it.to]) { que.push(it.to); inque[it.to] = true; }
						dis[it.to] = dis[cur] + it.cost;
						prev[it.to] = cur;
						path[it.to] = &it;
					}
				}
			}
			if (prev[t] == -1) { break; }
			ll flow = INF;
			for (ll i = t; i != s; i = prev[i]) {
				flow = min(flow, path[i]->spare());
			}
			fans += flow;
			for (ll i = t; i != s; i = prev[i]) {
				cans += path[i]->cost;
				add(*path[i],fans);
			}
		}
		ret.first = fans;
		ret.second = cans;
		return ret;
	}
};


// Circulation by Dinic O(V^2*E)
// LR-edge는 addLREdge로 추가한다
// LR-edge만 추가하면 query에서 자동으로 나머지 edge를 만들어준다.
// query함수는 존재하지 않을 경우에는 ans[0]=-1이 담긴 벡터를 리턴한다

struct circulation{
    struct Edge{
        int to,rev;
        ll c,f;
        Edge(){c=f=0;}
        Edge(int _to, ll _c) : to(_to), c(_c), f(0) {}
        ll spare() { return c - f; }
    };
    int N,M,s,t;
    vector<vector<Edge>> adj;
	vector<pi> E;
	vector<ll> D,LB;
    vector<int> level,see;
    queue<int> que;

    circulation(){N=M=s=t=0;}
    circulation(int n, int m, int _s, int _t){
        N=n; M=m; s=_s;t=_t;
		D.resize(N);
		LB.resize(M);
		E.resize(M);
        adj.resize(N);
        level.resize(N);
        see.resize(N);
    }
    void add(Edge& e, ll inc) {
        e.f+=inc;
        adj[e.to][e.rev].f -= inc;
    }
    void addEdge(int u, int v, ll c) {
        Edge e1 = Edge(v,c);
        Edge e2 = Edge(u,0);
        e1.rev = adj[v].size();
        e2.rev = adj[u].size();
        adj[u].push_back(e1);
        adj[v].push_back(e2);
    }
    void addLREdge(int u, int v, ll l, ll r, int idx) {
		D[u]+=l; D[v]-=l;
        Edge e1 = Edge(v,r-l);
        Edge e2 = Edge(u,0);
        e1.rev = adj[v].size();
        e2.rev = adj[u].size();
        adj[u].push_back(e1);
        adj[v].push_back(e2);
		LB[idx] = l;
		E[idx] = {u,adj[u].size()-1};
    }
    bool bfs() {
        for (int i=0;i<N;i++){level[i]=-1;}
        level[s] = 0; que.push(s);
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            for (auto& it : adj[cur]) {
                ll sp = it.spare();
                if (sp > 0 && level[it.to] == -1) {
                    que.push(it.to); level[it.to] = level[cur] + 1;
                }
            }
        }
        if (level[t] == -1) { return false; }
        return true;
    }
    ll dfs(int n, ll flow) {
        if (n == t) { return flow; }
        for (int& i = see[n]; i < (int)adj[n].size(); i++) {
            int next = adj[n][i].to;
            ll sp = adj[n][i].spare();
            if (sp > 0 && level[next] == level[n] + 1) {
                ll f = dfs(next, min(flow, sp));
                if (f > 0) { add(adj[n][i],f);return f; }
            }
        }
        return 0;
    }
    vector<ll> query() {
		vector<ll> ans(M);

		ll in,out; in=out=0;
		for (int i=0;i<N;i++){
			if (i==s || i==t){continue;}
			if (D[i]<0){out-=D[i]; addEdge(s,i,-D[i]);}
			else{in+=D[i]; addEdge(i,t,D[i]);}
		}
		
        ll ret = 0;
        while (bfs()) {
            for (int i=0;i<N;i++){see[i]=0;}
            while (true) {
                ll f = dfs(s, INF);
                if (f == 0) { break; }
                ret += f;
            }
        }
		if (in!=out || in!=ret){ ans.resize(1); ans[0]=-1; return ans;}
		for (int i=0;i<M;i++){
            int u,idx; u = E[i].first; idx = E[i].second;
			ans[i] = LB[i]+adj[u][idx].f;
		}
        return ans;
    }
};




// Bipartite Matching O(VE)
ll N, M;
ll L[MAX];
ll R[MAX];
ll visited[MAX];
vector<ll> adj[MAX];

bool dfs(ll n) {
	visited[n] = true;
	for (auto it : adj[n]) {
		if (R[it] == -1 || !visited[R[it]] && dfs(R[it])) {
			L[n] = it;
			R[it] = n;
			return true;
		}
	}
	return false;
}
ll bipartite() {
	ll ret = 0;
	memset(L, -1, sizeof(L));
	memset(R, -1, sizeof(R));
	while (true) {
		ll flow = 0;
		memset(visited, false, sizeof(visited));
		for (ll i = 0; i < N; i++) {
			if (L[i] == -1 && dfs(i)) { ++flow; }
		}
		if (flow == 0) { break; }
		ret += flow;
	}
	return ret;
}