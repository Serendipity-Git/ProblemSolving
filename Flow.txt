// Dinic algorithm O(V^2*E)
// 0-based이다
// 단방향 그래프이다

// fast version
struct maxflow{
    struct Edge{
        int u,v,rev=0;
        ll c,f=0;
        Edge(int u, int v, ll c) : u(u), v(v), c(c){}
        ll spare() { return c - f; }
    };
    
    int N,s,t;
    vector<vector<Edge>> adj;
    vector<int> level,see;
    queue<int> que;

    maxflow(){N=s=t=0;}
    maxflow(int n, int s, int t):N(n),s(s),t(t){
        level.resize(N);
        see.resize(N);
        adj.resize(N);
    }
    void add(Edge& e, ll inc) {
        e.f+=inc;
        adj[e.v][e.rev].f-=inc;
    }
    void addEdge(int u, int v, ll c, bool undirected = 0) {
        Edge e1 = Edge(u,v,c);
        if (undirected){
            Edge e2 = Edge(v,u,c);
            e1.rev = adj[v].size();
            e2.rev = adj[u].size();
            adj[u].push_back(e1);
            adj[v].push_back(e2);
        }
        else{
            Edge e2 = Edge(v,u,0);
            e1.rev = adj[v].size();
            e2.rev = adj[u].size();
            adj[u].push_back(e1);
            adj[v].push_back(e2);
        }
    }
    bool bfs() {
        for (int i=0;i<N;i++){level[i]=-1;}
        level[s] = 0; que.push(s);
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            for (auto& it : adj[cur]) {
                ll sp = it.spare();
                if (sp > 0 && level[it.v] == -1) {
                    que.push(it.v); level[it.v] = level[cur] + 1;
                }
            }
        }
        if (level[t] == -1) { return false; }
        return true;
    }
    ll dfs(int n, ll flow) {
        if (n == t) { return flow; }
        for (int& i = see[n]; i < (int)adj[n].size(); i++) {
            Edge& e = adj[n][i];
            int next = e.v;
            ll sp = e.spare();
            if (sp > 0 && level[next] == level[n] + 1) {
                ll f = dfs(next, min(flow, sp));
                if (f > 0) { add(e,f); return f; }
            }
        }
        return 0;
    }
    ll query() {
        ll ret = 0;
        while (bfs()) {
            for (int i=0;i<N;i++){see[i]=0;}
            while (true) {
                ll f = dfs(s, LLINF);
                if (f == 0) { break; }
                ret += f;
            }
        }
        return ret;
    }
};

// easy version
struct maxflow{
    struct edge{
        int u,v;
        ll c,f=0;
        edge(int u, int v, ll c):u(u),v(v),c(c){}

    };

    int N,s,t,M=0;
    vector<edge> E;
    vector<int> level,see;
    vector<vector<int>> adj;
    queue<int> que;

    maxflow(int N, int s, int t):N(N),s(s),t(t){
        level.resize(N); see.resize(N); adj.resize(N);
    }

    void addEdge(int u, int v, ll c, bool undirected=0){
        if (undirected){
            E.emplace_back(u,v,c);
            E.emplace_back(v,u,c);
        }else{
            E.emplace_back(u,v,c);
            E.emplace_back(v,u,0);
        }
        adj[u].push_back(M);
        adj[v].push_back(M+1);
        M+=2;
    }
    bool bfs(){
        fill(level.begin(),level.end(),-1);
        que.push(s); level[s]=0;
        while(!que.empty()){
            int u = que.front(); que.pop();
            for (int& e:adj[u]){
                int v = E[e].v;
                if (E[e].c-E[e].f>0 && level[v]==-1){
                    level[v] = level[u]+1; que.push(v);
                }
            }
        }
        return (level[t]!=-1);
    }
    ll dfs(int u, ll flow){
        if (u==t){return flow;}
        if (flow==0){return 0;}

        for (int& i=see[u]; i<(int)adj[u].size();i++){
            int e = adj[u][i];
            ll sp = E[e].c - E[e].f;
            int v = E[e].v;
            if (sp>0 && level[v]==level[u]+1){
                ll f = dfs(v,min(flow,sp));
                if (f>0){
                    E[e].f+=f;
                    E[e^1].f-=f;
                    return f;
                }
            }
        }
        return 0;
    }
    ll query(){
        ll ans=0;
        while(bfs()){
            fill(see.begin(),see.end(),0);
            while(ll flow = dfs(s,LLINF)){
                ans+=flow;
            }
        }
        return ans;
    }
};


// Hopcroft-Karp O(E*sqrt(V))
// 0-based이다
// 양방향이다
// L->R로만 edge를 추가해주면 된다

// konigs theorem
// 이분 그래프에서 |Minimum V.C.| = |Maximum Matching|
// Minimum V.C. = 전체 vertex - Independent Set

struct bimatch{
    int N,M;
    vector<int> L,R,level,see;
    vector<vector<int>> adj;
    queue<int> que;

    bimatch(){N=M=0;}
    bimatch(int n, int m){
        N=n; M=m;
        L.resize(N); R.resize(M);
        level.resize(N); see.resize(N);
        adj.resize(N);
    }
    void addEdge(int u, int v){
        adj[u].push_back(v);
    }
    bool dfs(int n) {
        for (; see[n] < adj[n].size(); see[n]++) {
            int it = adj[n][see[n]];
            if (R[it] == -1 || level[R[it]] == level[n] + 1 && dfs(R[it])) {
                L[n] = it;
                R[it] = n;
                return true;
            }
        }
        return false;
    }
    void bfs() {
        for (int i = 0; i < N; i++) {
            if (L[i] == -1) { que.push(i); level[i] = 0; }
            else { level[i] = INF; }
            see[i] = 0;
        }
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            for (auto it : adj[cur]) {
                if (R[it] != -1 && level[R[it]] == INF) {
                    que.push(R[it]); level[R[it]] = level[cur] + 1;
                }
            }
        }
    }
    ll query() {
        ll ret = 0;
        for (int i=0;i<N;i++){L[i]=-1;}
        for (int i=0;i<M;i++){R[i]=-1;}
        while (true) {
            bfs();
            ll flow = 0;
            for (int i = 0; i < N; i++) {
                if (L[i] == -1 && dfs(i)) { ++flow; }
            }
            if (flow == 0) { break; }
            ret += flow;
        }
        return ret;
    }

	vector<pi> VC(){
		vector<vector<int>> new_adj(N+M);
		vector<bool> visited(N+M);
		vector<pi> ret;
		for (int i=0;i<N;i++){
			for (auto& it:adj[i]){
				if (it!=L[i]){new_adj[i].push_back(it+N);}
			}
		}
		for (int i=0;i<M;i++){
			if (R[i]!=-1){new_adj[i+N].push_back(R[i]);}			
		}
		
		for (int i=0;i<N;i++){
			if (L[i]==-1){que.push(i); visited[i]=true;}
		}
		while(!que.empty()){
			int tmp = que.front();que.pop();
			for (auto& it:new_adj[tmp]){
				if (!visited[it]){que.push(it); visited[it]=true;}
			}
		}
		for (int i=0;i<N;i++){
			if (!visited[i]){ret.push_back({i,0});}
		}
		for (int i=N;i<N+M;i++){
			if (visited[i]){ret.push_back({i-N,1});}
		}
		return ret;
	}
	vector<pi> IS(){
		vector<vector<int>> new_adj(N+M);
		vector<bool> visited(N+M);
		vector<pi> ret;
		for (int i=0;i<N;i++){
			for (auto& it:adj[i]){
				if (it!=L[i]){new_adj[i].push_back(it+N);}
			}
		}
		for (int i=0;i<M;i++){
			if (R[i]!=-1){new_adj[i+N].push_back(R[i]);}			
		}
		
		for (int i=0;i<N;i++){
			if (L[i]==-1){que.push(i); visited[i]=true;}
		}
		while(!que.empty()){
			int tmp = que.front();que.pop();
			for (auto& it:new_adj[tmp]){
				if (!visited[it]){que.push(it); visited[it]=true;}
			}
		}
		for (int i=0;i<N;i++){
			if (visited[i]){ret.push_back({i,0});}
		}
		for (int i=N;i<N+M;i++){
			if (!visited[i]){ret.push_back({i-N,1});}
		}
		return ret;
	}
};


// MaxFlow - MinCost O(V*E*F)~O(E*F)
// 0-based이다
// 단방향이다
// edge의 cost까지도 추가해줘야 한다

// fast version
struct MCMF{
    struct Edge {
        int to,rev;
        ll cap, flow, cost;
        Edge(){to=rev=cap=flow=cost=0;}
        Edge(int _to, ll _cap, ll _cost) :to(_to), cap(_cap), cost(_cost), flow(0) {}
        ll spare() { return cap - flow; }
    };
	int N,s,t;
	vector<vector<Edge>> adj;

	MCMF(){N=s=t=0;}
	MCMF(int _n, int _s, int _t){
		N=_n; s=_s; t=_t;
		adj.resize(N);
	}
    void add(Edge& e, ll inc) {
        e.flow+=inc;
        adj[e.to][e.rev].flow-=inc;
    }
	void addEdge(int u, int v, ll cap, ll cost) {
        Edge e1 = Edge(v,cap,cost);
        Edge e2 = Edge(u,0,-cost);
        e1.rev = adj[v].size();
        e2.rev = adj[u].size();
        adj[u].push_back(e1);
        adj[v].push_back(e2);
	}

	pair<ll, ll> query() {
		pii ret;
		ll cans = 0, fans = 0;
		while (true) {
			vector<ll> dis(N,LLINF);
			vector<int> prev(N,-1);
			vector<bool> inque(N);
			vector<Edge*> path(N);
			queue<int> que;

			que.push(s); inque[s] = true; dis[s] = 0;
			while (!que.empty()) {
				int cur = que.front(); que.pop(); inque[cur] = false;
				for (auto& it : adj[cur]) {
					if (it.spare() > 0 && dis[it.to] > dis[cur] + it.cost) {
						if (!inque[it.to]) { que.push(it.to); inque[it.to] = true; }
						dis[it.to] = dis[cur] + it.cost;
						prev[it.to] = cur;
						path[it.to] = &it;
					}
				}
			}
			if (prev[t] == -1) { break; }
			ll flow = INF;
			for (ll i = t; i != s; i = prev[i]) {
				flow = min(flow, path[i]->spare());
			}
			fans += flow;
			for (ll i = t; i != s; i = prev[i]) {
				cans += path[i]->cost;
				add(*path[i],fans);
			}
		}
		ret.first = fans;
		ret.second = cans;
		return ret;
	}
};

// easy version
struct mcmf{
    struct edge{
        int u,v;
        ll c,f=0,w;
        edge(int u, int v, ll c, ll w):u(u),v(v),c(c),w(w){}
    };

    int N,s,t,M=0;
    vector<edge> E;
    vector<int> vis;
    vector<ll> dis,flow;
    vector<vector<int>> adj;
    queue<int> que;

    mcmf(int N, int s, int t):N(N),s(s),t(t){
        adj.resize(N);
        vis.resize(N);
        dis.resize(N);
        flow.resize(N);
    }

    void addEdge(int u, int v, ll c, ll w){
        E.emplace_back(u,v,c,w);
        E.emplace_back(v,u,0,-w);
        adj[u].push_back(M);
        adj[v].push_back(M+1);
        M+=2;
    }
    pii spfa(){
        fill(flow.begin(),flow.end(),LLINF);
        fill(dis.begin(),dis.end(),LLINF);
        fill(vis.begin(),vis.end(),-1);
        que.push(s); dis[s]=0;
        while(!que.empty()){
            int u = que.front(); que.pop();
            for (int& e:adj[u]){
                int v = E[e].v;
                ll w = E[e].w;
                ll sp = E[e].c - E[e].f;
                if (sp>0 && dis[v]>dis[u]+w){
                    dis[v] = dis[u]+w;
                    vis[v] = e;
                    flow[v] = min(sp,flow[u]);
                    que.push(v);
                }
            }
        }
        if (vis[t]==-1){return {0,0};}
        if (flow[t]==0){return {0,0};}

        int v = t;
        ll fret = flow[t];
        ll wret = 0;
        while(v!=s){
            int e = vis[v];
            int u = E[e].u;
            ll w = E[e].w;
            wret+=w*fret;
            E[e].f+=fret;
            E[e^1].f-=fret;
            v = u;
        }
        return {fret,wret};
    }
    pii query(){
        pii ans={0,0};
        while(true){
            pii ret = spfa();
            ll f,w; f=ret.first; w=ret.second;
            ans.first+=f; ans.second+=w;
            if (f==0){break;}
        }
        return ans;
    }
};


// Circulation by Dinic O(V^2*E)
// addEdge(u,v,l,r)로 edge 추가
// maxflow > graph.sum이면 가능한 flow가 없는 것이다.
// 설계한 circulation graph의 edge를 모두 설정하고 init()으로 circulation graph를 만든다
// 가능한 flow가 존재한다면, E[e].l + E[e].f로 e에 흐르는 실제 flow를 구할 수 있다.

struct circulation{
    struct edge{
        int u,v;
        ll c,l,f=0;
        edge(int u, int v, ll c, ll l):u(u),v(v),c(c),l(l){}
    };

    int N,s,t,s_,t_,M=0;
    ll sum=0;
    vector<ll> d;
    vector<int> level,see;
    vector<vector<int>> adj;
    vector<edge> E;
    queue<int> que;

    circulation(int N, int s, int t, int s_, int t_):N(N),s(s),t(t),s_(s_), t_(t_){
        level.resize(N); see.resize(N); d.resize(N);
        adj.resize(N);
    }
    void addEdge(int u, int v, ll l, ll r){
        d[u]+=l;
        d[v]-=l;
        E.emplace_back(u,v,r-l,l);
        E.emplace_back(v,u,0,0);
        adj[u].push_back(M);
        adj[v].push_back(M+1);
        M+=2;
    }
    void init(){
        for (int i=0;i<N;i++){
            if (i==s_ || i==t_){continue;}
            if (d[i]>0){
                addEdge(i,t_,0,d[i]);
                sum+=d[i];
            }else if (d[i]<0){
                addEdge(s_,i,0,-d[i]);
            }
        }
    }
    bool bfs(){
        fill(level.begin(),level.end(),-1);
        level[s_]=0; que.push(s_);
        while(!que.empty()){
            int u = que.front(); que.pop();
            for (int e:adj[u]){
                int v = E[e].v;
                ll sp = E[e].c - E[e].f;
                if (sp>0 && level[v]==-1){
                    level[v]=level[u]+1;
                    que.push(v);
                }
            }
        }
        return (level[t_]!=-1);
    }
    ll dfs(int u ,ll flow){
        if (u==t_){return flow;}
        if (flow==0){return 0;}

        for (int& i=see[u]; i<(int)adj[u].size();i++){
            int e = adj[u][i];
            ll sp = E[e].c - E[e].f;
            int v = E[e].v;
            if (sp>0 && level[v]==level[u]+1){
                ll f = dfs(v,min(flow,sp));
                if (f>0){
                    E[e].f+=f;
                    E[e^1].f-=f;
                    return f;
                }
            }
        }
        return 0;
    }
    ll query(){
        ll ans = 0;
        while(bfs()){
            fill(see.begin(),see.end(),0);
            while(ll f = dfs(s_,LLINF)){
                ans+=f;
            }
        }   
        return ans;
    }
};


// Blossom Algorithm O(VE)
// 1-based 
// maximum matching in general graph
struct Blossom{
    // 출처 : https://blog.kyouko.moe/20
    int t,N;
    vector<int> vis,par,bl,match,aux;
    vector<vector<int>> g;
    queue<int> que;

    Blossom(int n){
        N=n; t=0;
        vis.resize(N+1);
        bl.resize(N+1);
        par.resize(N+1);
        match.resize(N+1);
        aux.resize(N+1);
        g.resize(N+1);
    };
    void addEdge(int u, int v){
        g[u].push_back(v);
        g[v].push_back(u);
    }
    void augment(int u, int v) {
        int pv = v, nv;
        do {
            pv = par[v]; nv = match[pv];
            match[v] = pv; match[pv] = v;
            v = nv;
        } while(u != pv);
    }
    int lca(int v, int w) {
        ++t;
        while(true) {
            if (v) {
                if(aux[v] == t) {return v;}
                aux[v] = t;
                v = bl[par[match[v]]];
            }
            swap(v, w);
        }
    }
    void blossom(int v, int w, int a) {
        while(bl[v] != a) {
            par[v] = w; w = match[v];
            if(vis[w] == 1) {que.push(w); vis[w] = 0;}
            bl[v] = bl[w] = a;
            v = par[w];
        }
    }
    bool bfs(int u) {
        for (int i=1;i<=N;i++){
            vis[i]=-1;
            bl[i]=i;
        }
        while(!que.empty()){que.pop();}
        que.push(u); vis[u]=0;
        while(!que.empty()) {
            int v = que.front(); que.pop();
            for(int x: g[v]) {
                if(vis[x] == -1) {
                    par[x] = v; vis[x] = 1;
                    if(!match[x]) {augment(u,x); return true;}
                    que.push(match[x]); vis[match[x]]=0;
                }
                else if(vis[x] == 0 && bl[v] != bl[x]) {
                    int a = lca(bl[v], bl[x]);
                    blossom(x, v, a); blossom(v, x, a);
                }
            }
        }
        return false;
    }
    int query(){
        int ans=0;
        for (int i=1;i<=N;i++){
            if (!match[i] && bfs(i)){++ans;}
        }
        return ans;
    }
};
