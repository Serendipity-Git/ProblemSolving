
// Fast Fourier Transform && convolution
// query(A,B)는 다항식 A와 B의 곱을 벡터로 리턴한다.

struct FFT{
    // 출처: https://blog.myungwoo.kr/54 [PS 이야기]
	FFT(){;}

    void fft(vector<inum>& a) {
        int n = a.size(), L = 31 - __builtin_clz(n);
        static vector<complex<ld>> R(2, 1);
        static vector<inum> rt(2, 1);
        for (static int k = 2; k < n; k *= 2) {
            R.resize(n); rt.resize(n);
            auto x = polar(1.0L, acos(-1.0L) / k);
            for (int i=k;i<k+k;i++) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];
        }
        vector<int> rev(n);
        for (int i=0;i<n;i++) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
        for (int i=0;i<n;i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int k = 1; k < n; k *= 2){
            for (int i = 0; i < n; i += 2 * k) for (int j=0;j<k;j++) {
                auto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];                
                inum z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);     
                a[i + j + k] = a[i + j] - z;
                a[i + j] += z;
            }
        }
    }
 
    vector<ll> query(const vector<ll>& a, const vector<ll>& b) {
        if (a.empty() || b.empty()) return {};
        vector<ll> ret(a.size()+b.size() - 1);
        int L = 32 - __builtin_clz(ret.size()), n = 1 << L;
        vector<inum> in(n), out(n);
        copy(a.begin(),a.end(), begin(in));
        for (int i=0;i<b.size();i++) in[i].imag(b[i]);
        fft(in);
        for (inum& x: in) x *= x;
        for (int i=0;i<n;i++) out[i] = in[-i & (n - 1)] - conj(in[i]);
        fft(out);
        for (int i=0;i<ret.size();i++){
            ret[i] = static_cast<ll>(imag(out[i]) / (4 * n) + (is_integral_v<ll> ? (imag(out[i]) > 0 ? 0.5 : -0.5) : 0));
        }
        return ret;
    }
};


// Convex hull trick
DP[i] = max(M[j]*X[i] + N[j]) + C[i] (j<i)
로 주어질 때, 사용 가능하다.

// special case for CHT
// add로 주어지는 직선의 M이 증가할때
// query로 주어지는 X가 증가할때
// special하게 O(N)에 작동
struct line {
    ll m, n; ld from;
    line(){m=n=0; from=-1.0*INF;}
    line(ll _m, ll _n) : m(_m), n(_n), from(-INF) {}
    ld cross(const line& other) {
        return 1.0 * (other.n - n) / (m - other.m);
    }
};
struct maxhull{
    int N,lo;
    vector<line> hull;
    
    maxhull(){N=lo=0;}
    maxhull(int n){
        N=n; lo=0;
        hull.reserve(N);
    }
    void add(ll m, ll n){
        line newline = line(m,n);
        while (!hull.empty()) {
            line top = hull.back();
            if (top.from < newline.cross(top)) {
                newline.from = newline.cross(top);
                break;
            }
            hull.pop_back();
            if (lo == hull.size()) { --lo; }
        }
        hull.push_back(newline);       
    }
    ll query(ll x){
        while(lo+1<hull.size() && hull[lo+1].from < x){++lo;}
        ll ret = hull[lo].m * x + hull[lo].n;
        return ret;    
    }
};

struct line {
    ll m, n; ld from;
    line(){m=n=0; from=-1.0*INF;}
    line(ll _m, ll _n) : m(_m), n(_n), from(-INF) {}
    ld cross(const line& other) {
        return 1.0 * (other.n - n) / (m - other.m);
    }
};
struct minhull{
    int N,lo;
    vector<line> hull;
    
    minhull(){N=lo=0;}
    minhull(int n){
        N=n; lo=0;
        hull.reserve(N);
    }
    void add(ll m, ll n){
        line newline = line(-m,-n);
        while (!hull.empty()) {
            line top = hull.back();
            if (top.from < newline.cross(top)) {
                newline.from = newline.cross(top);
                break;
            }
            hull.pop_back();
            if (lo == hull.size()) { --lo; }
        }
        hull.push_back(newline);       
    }
    ll query(ll x){
        while(lo+1<hull.size() && hull[lo+1].from < x){++lo;}
        ll ret = hull[lo].m * x + hull[lo].n;
        return -ret;    
    }
};


// Convex hull Trick (Online)
// Online CHT O(nlogn)
// Reference from https://github.com/kth-competitive-programming/kactl/blob/master/content/data-structures/LineContainer.h
// MAX Convex Hull Trick API
// To convert minCHT, input -m, -n and output -query.

struct Line {
	mutable ll k, m, p;
	bool operator<(const Line& o) const { return k < o.k; }
	bool operator<(ll x) const { return p < x; }
};
struct LineContainer : multiset<Line, less<>> {
    // Reference from https://github.com/kth-competitive-programming/kactl/blob/master/content/data-structures/LineContainer.h
    // MAX Convex Hull Trick API
	// (for doubles, use inf = 1/.0, div(a,b) = a/b)
	static const ll inf = LLONG_MAX;
	ll div(ll a, ll b) { // floored division
		return a / b - ((a ^ b) < 0 && a % b);
	}
	bool isect(iterator x, iterator y) {
		if (y == end()) return x->p = inf, 0;
		if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;
		else x->p = div(y->m - x->m, x->k - y->k);
		return x->p >= y->p;
	}
	void add(ll k, ll m) {
		auto z = insert({ k, m, 0 }), y = z++, x = y;
		while (isect(y, z)) z = erase(z);
		if (x != begin() && isect(--x, y)) isect(x, y = erase(y));
		while ((y = x) != begin() && (--x)->p >= y->p)
			isect(x, erase(y));
	}
	ll query(ll x) {
		assert(!empty());
		auto l = *lower_bound(x);
		return l.k * x + l.m;
	}
};
struct minhull{
    LineContainer hull;

    minhull(){;}
    void add(ll m, ll n){
        hull.add(-m,-n);
    }
    ll query(ll x){
        return -hull.query(x);
    }
};

struct Line {
	mutable ll k, m, p;
	bool operator<(const Line& o) const { return k < o.k; }
	bool operator<(ll x) const { return p < x; }
};
struct LineContainer : multiset<Line, less<>> {
    // Reference from https://github.com/kth-competitive-programming/kactl/blob/master/content/data-structures/LineContainer.h
    // MAX Convex Hull Trick API
	// (for doubles, use inf = 1/.0, div(a,b) = a/b)
	static const ll inf = LLONG_MAX;
	ll div(ll a, ll b) { // floored division
		return a / b - ((a ^ b) < 0 && a % b);
	}
	bool isect(iterator x, iterator y) {
		if (y == end()) return x->p = inf, 0;
		if (x->k == y->k) x->p = x->m > y->m ? inf : -inf;
		else x->p = div(y->m - x->m, x->k - y->k);
		return x->p >= y->p;
	}
	void add(ll k, ll m) {
		auto z = insert({ k, m, 0 }), y = z++, x = y;
		while (isect(y, z)) z = erase(z);
		if (x != begin() && isect(--x, y)) isect(x, y = erase(y));
		while ((y = x) != begin() && (--x)->p >= y->p)
			isect(x, erase(y));
	}
	ll query(ll x) {
		assert(!empty());
		auto l = *lower_bound(x);
		return l.k * x + l.m;
	}
};
struct maxhull{
    LineContainer hull;

    maxhull(){;}
    void add(ll m, ll n){
        hull.add(m,n);
    }
    ll query(ll x){
        return hull.query(x);
    }
};


// Knuth optimization
// O(N^3) -> O(N^2)
// 구간을 쪼개어가는 DP를 최적화한다

1. DP[i][j]가 1<=i<=j<=n일때만 정의된다.
2. DP[i][j] = min(DP[i][k] + DP[k][j]) + cost[i][j]
a<=b<=c<=d 일때,
3. cost[a][c] + cost[b][d] <= cost[a][d] + cost[b][c]
4. cost[b][c] <= cost[a][d]

라면 Knuth optimization을 이용할 수 있다.

3번과 4번을 만족한다면, P[i][j]를 DP[i][j] 문제에서
최소로 만드는 k의 값이라고 정의할 때,

P[i][j-1] <= P[i][j] <= P[i+1][j]를 만족한다. (i<j)
-> k값을 찾는데 범위를 줄여줌
-> P[a][b]라고 하면 b-a가 커지는 순서로 루프를 돌려야함

for (int j=1;j<=N;j++){ // j는 차이
    for (int i=0;i+j<=N;i++){ // i는 시작 index
        for (int k=key[i][i+j-1];k<=key[i+1][i+j];k++){
            // k는 다음 최소값의 후보군이다.
        }
    }
}



// Divide and Conquer optimization 
// O(KN^2) -> O(KNlogN)
// DP(t,i) = min DP(t-1,j-1) + c(j,i) (j<=i) 인 점화식에 사용

t번째 row를 채울때, opt(i)는 DP(t,i)를 최소로 만드는
j값이라고 하자. opt(i)의 경향이 단조적이면 DNC Optimization이 가능하다.

c(j,i)가 사각부등식을 만족시키면 opt(i)는 단조적이다. c(a,c) + c(b,d) <= c(a,d) + c(b,c) (a<b<c<d)
또는 직접 opt(i)의 단조성을 얻어서 사용할 수도 있음

t번째 row를 채우는 순서를 바꾼다고 생각하면 쉽다.

하나의 row 채우는 코드
function<void(int,int,int,int)> calc=[&](int l, int r, int optl, int optr){
    if (l>r){return;}
    int mid = (l+r)>>1;
    pair<ll,int> ret = {LLINF,-1};
    for (int i=optl;i<=min(mid,optr);i++){
        ret = min(ret,{dp[i-1]+c(i,mid),i});
    }
    new_dp[mid] = ret.first;
    int opt = ret.second;
    calc(l,mid-1,optl,opt);
    calc(mid+1,r,opt,optr);
};
