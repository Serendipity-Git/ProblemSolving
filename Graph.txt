// Strongly Connected Component (0-based)
struct SCC{
    int N,cnt,scnt;
    vector<vector<int>> adj;
    vector<int> dfsn,scc;
    stack<int> stk;

    SCC(){N=cnt=scnt=0;}
    SCC(int n){
        N=n;
        cnt=scnt=0;
        adj.resize(N);
        dfsn.resize(N);
        scc.resize(N);
        for (int i=0;i<N;i++){
            dfsn[i]=scc[i]=-1;
        }
    }

    void addEdge(int u, int v){
        adj[u].push_back(v);
    }

    void init(){
        for (int i=0;i<N;i++){
            if (dfsn[i]==-1){dfs(i);}
        }
    }

    int dfs(int n){
        dfsn[n]=cnt; ++cnt; stk.push(n);

        int ret = dfsn[n];
        for (auto& it:adj[n]){
            if (dfsn[it]==-1){ret=min(ret,dfs(it));}
            else{
                if (scc[it]==-1){ret=min(ret,dfsn[it]);}
            }
        }

        if (ret==dfsn[n]){
            while(!stk.empty()){
                int tmp = stk.top(); stk.pop();
                scc[tmp]=scnt;
                if (tmp==n){break;}
            }
            scnt++;
        }
        return ret;
    }   
};

// Heavy-Light Decomposition (0-based)
struct HLD{
    int N,cnt;
    vector<int> h,par,pos,head,heavy;
    vector<vector<int>> g;

    HLD(int n){
        N=n; cnt=0;
        h.resize(n,-1);
        par.resize(n,-1);
        pos.resize(n,-1);
        head.resize(n,-1);
        heavy.resize(n,-1);
        g.resize(n);
    }
    void init(int r){
        h[r]=0;
        dfs(r);
        decompose(r,r);
    }
    int dfs(int u){
        int ret = 1;
        int m,c; m=c=-1;
        for (int& v:g[u]){
            if (par[u]==v){continue;}
            h[v]=h[u]+1;
            par[v]=u;
            int sub = dfs(v);
            ret+=sub;
            if (sub>m){
                m=sub; heavy[u]=v;
            }
        }
        return ret;    
    }
    void decompose(int u, int h){
        pos[u]=cnt; ++cnt; head[u]=h;
        if (heavy[u]!=-1){
            decompose(heavy[u],h);
        }
        for (int& v:g[u]){
            if (par[u]==v){continue;}
            if (v==heavy[u]){continue;}
            decompose(v,v);
        }
    }
    int query(int u, int v){
        int ret = 0;
        while(head[u]!=head[v]){
            if (h[head[u]]>h[head[v]]){swap(u,v);}
            // ret = seg.query(pos[head[v]],pos[v]);
            // define ds + operation
            v = par[head[v]];
        }
        if (h[u]>h[v]){swap(u,v);}
        // ret = seg.query(pos[u]+1,pos[v]); (edge query)
        // ret = seg.query(pos[u],pos[v])l (vertex query)
        // 해당 line은 edge에 관한 query인지 vertex에 관한 query인지에 따라 다르다
        return ret;
    }
};

// Centroid Decomposition (0-based)
struct Centroid{
    int N;
    vector<int> sub;
    vector<bool> vis;
    vector<vector<int>> g;

    void dfs(int u, int p){
        int& ret = sub[u];
        ret=1;
        for (int& v:g[u]){
            if (vis[v] || v==p){continue;}
            ret+=dfs(v,u);
        }
        return ret;
    }
    int cent(int u, int p, int sz){
        for (int& v:g[u]){
            if (vis[v] || v==p){continue;}
            if (2*sub[v]>sz){return cent(v,u,sz);} 
        }
        return u;
    }
    
    // 답 구할때 필요한 탐색을 하는 function
    // operation을 정의해서 알맞게 변형해야 한다
    void dfs2(int u, int p, int d, vector<int>& tmp){
        tmp.push_back(d);
        for (int& v:g[u]){
            if (v==p || vis[v]){continue;}
            dfs2(v,u,d+1,tmp);
        }
    }

    // Divide and Conquer로 답 구하는 function
    // 필요한 operation을 정의해야 한다
    void calc(int u){
        int sz = dfs(u,-1);
        int cen = cent(u,-1,sz);
        vis[cen]=1;
        
        // vector<int> store; // 무언가 기록할 것
        // store.push_back(cen);
        // cen에서 처리해야 할 것을 먼저 처리하는 부분
        for (int& v:g[cen]){
            vector<int> tmp;
            dfs2(v,cen,tmp);
            for (int& x:tmp){
                // ans = min(ans, x); // 필요한 operation 처리
            }
            for (int& x:tmp){
                // dis[x] = min(dis[x], x); // tmp 정보로 update
            }
        }

        // 원래대로 돌려놓는 과정
        for (auto& x:store){
            // dis[x] = INF; // 원래대로 초기화 해야 한다.
        }
        
        // cen의 subtree들에 대해서 재귀적으로 수행한다.
        for (int& v:g[cen]){
            if (!vis[v]){calc(v);}
        }
    }
};
