// Strongly Connected Component (0-based)
struct SCC{
    int N,cnt,scnt;
    vector<int> dfsn,scc;
    stack<int> stk;
    SCC(vector<vector<int>>& g){
        N = g.size();
        cnt=scnt=0;
        dfsn.resize(N,-1);
        scc.resize(N,-1);
        for (int i=0;i<N;i++){
            if (dfsn[i]==-1){dfs(g,i);}
        }
    }
    int dfs(vector<vector<int>>& g, int n){
        dfsn[n]=cnt; ++cnt; stk.push(n);
        int ret = dfsn[n];
        for (auto& it:g[n]){
            if (dfsn[it]==-1){ret=min(ret,dfs(g,it));}
            else{
                if (scc[it]==-1){ret=min(ret,dfsn[it]);}
            }
        }
        if (ret==dfsn[n]){
            while(!stk.empty()){
                int tmp = stk.top(); stk.pop();
                scc[tmp]=scnt;
                if (tmp==n){break;}
            }
            scnt++;
        }
        return ret;
    }   
};

// Heavy-Light Decomposition (0-based)
struct HLD{
    int N,cnt;
    vector<int> h,par,pos,head,heavy;
    vector<vector<int>> g;

    HLD(int n){
        N=n; cnt=0;
        h.resize(n,-1);
        par.resize(n,-1);
        pos.resize(n,-1);
        head.resize(n,-1);
        heavy.resize(n,-1);
        g.resize(n);
    }
    void init(int r){
        h[r]=0;
        dfs(r);
        decompose(r,r);
    }
    int dfs(int u){
        int ret = 1;
        int m,c; m=c=-1;
        for (int& v:g[u]){
            if (par[u]==v){continue;}
            h[v]=h[u]+1;
            par[v]=u;
            int sub = dfs(v);
            ret+=sub;
            if (sub>m){
                m=sub; heavy[u]=v;
            }
        }
        return ret;    
    }
    void decompose(int u, int h){
        pos[u]=cnt; ++cnt; head[u]=h;
        if (heavy[u]!=-1){
            decompose(heavy[u],h);
        }
        for (int& v:g[u]){
            if (par[u]==v){continue;}
            if (v==heavy[u]){continue;}
            decompose(v,v);
        }
    }
    int query(int u, int v){
        int ret = 0;
        while(head[u]!=head[v]){
            if (h[head[u]]>h[head[v]]){swap(u,v);}
            // ret = seg.query(pos[head[v]],pos[v]);
            // define ds + operation
            v = par[head[v]];
        }
        if (h[u]>h[v]){swap(u,v);}
        // ret = seg.query(pos[u]+1,pos[v]); (edge query)
        // ret = seg.query(pos[u],pos[v])l (vertex query)
        // 해당 line은 edge에 관한 query인지 vertex에 관한 query인지에 따라 다르다
        return ret;
    }
};

// Centroid Decomposition (0-based)
struct centroid{
    vector<int> sub,vis,par;
    vector<vector<int>> g;
    int count(int u, int p){
        sub[u] = 1;
        for (int& v:g[u]){
            if (v==p || vis[v]){continue;}
            sub[u] += count(v,u);
        }
        return sub[u];
    }
    int cent(int u, int p, int sz){
        for (int& v:g[u]){
            if (v==p || vis[v]){continue;}
            if (2*sub[v] > sz){return cent(v,u,sz);}
        }
        return u;
    }
    void init(int u, int p){
        int sz = count(u,-1);
        int cen = cent(u,p,sz);
        vis[cen] = 1;
        par[cen] = p;
        for (int& v:g[cen]){
            if (!vis[v]){
                init(v,cen);
            }
        }
    }
};