// 0-based 사용했다
struct dijkstra {
    ll s;
    vector<vector<ll>> adj;
    vector<vector<ll>> cost;
    vector<ll> dist;
    priority_queue<pii> pq;


    dijkstra() { s = 0; }
    dijkstra(ll n, ll _s) {
        adj.resize(n);
        dist.resize(n);
        cost.resize(n);
        dist.resize(n);
        for (int i = 0; i < n; i++) { dist[i] = LLINF; }
        s = _s;
    }
    
    // u->v로 가는, 가중치 c의 edge를 생성한다
    void addEdge(ll u, ll v, ll c) {
        adj[u].push_back(v);
        cost[u].push_back(c);
    }

    // dijkstra를 수행한다
    void find() { 
        dist[s]=0;
        pq.push(make_pair(0, s));
        while (!pq.empty()) {
            pii tmp = pq.top(); pq.pop();
            ll cur = tmp.second;
            if (dist[cur] < -tmp.first) { continue; }
            for (int i = 0; i < adj[cur].size(); i++) {
                if (dist[adj[cur][i]] > dist[cur] + cost[cur][i]) {
                    pq.push(make_pair(-dist[cur] - cost[cur][i], adj[cur][i]));
                    dist[adj[cur][i]] = dist[cur]+cost[cur][i];
                }
            }
        }
    }
};


// 1-based 사용했다
struct SCC{
    int N,cnt,scnt;
    vector<vector<int>> adj;
    vector<int> dfsn,scc;
    stack<int> stk;

    SCC(){N=cnt=scnt=0;}
    SCC(int n){
        N=n;
        cnt=scnt=0;
        adj.resize(N+1);
        dfsn.resize(N+1);
        scc.resize(N+1);
        for (int i=1;i<=N;i++){
            dfsn[i]=scc[i]=-1;
        }
    }

    void addEdge(int u, int v){
        adj[u].push_back(v);
    }

    void init(){
        for (int i=1;i<=N;i++){
            if (dfsn[i]==-1){dfs(i);}
        }
    }

    int dfs(int n){
        dfsn[n]=cnt; ++cnt; stk.push(n);

        int ret = dfsn[n];
        for (auto& it:adj[n]){
            if (dfsn[it]==-1){ret=min(ret,dfs(it));}
            else{
                if (scc[it]==-1){ret=min(ret,dfsn[it]);}
            }
        }

        if (ret==dfsn[n]){
            while(!stk.empty()){
                int tmp = stk.top(); stk.pop();
                scc[tmp]=scnt;
                if (tmp==n){break;}
            }
            scnt++;
        }
        return ret;
    }   
};