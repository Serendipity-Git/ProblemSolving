// Heavy-Light Decomposition (0-based)
struct HLD{
    int N,cnt;
    vector<int> h,par,pos,head,heavy;
    vector<vector<int>> g;

    HLD(int n){
        N=n; cnt=0;
        h.resize(n,-1);
        par.resize(n,-1);
        pos.resize(n,-1);
        head.resize(n,-1);
        heavy.resize(n,-1);
        g.resize(n);
    }
    void init(int r){
        h[r]=0;
        dfs(r);
        decompose(r,r);
    }
    int dfs(int u){
        int ret = 1;
        int m,c; m=c=-1;
        for (int& v:g[u]){
            if (par[u]==v){continue;}
            h[v]=h[u]+1;
            par[v]=u;
            int sub = dfs(v);
            ret+=sub;
            if (sub>m){
                m=sub; heavy[u]=v;
            }
        }
        return ret;    
    }
    void decompose(int u, int h){
        pos[u]=cnt; ++cnt; head[u]=h;
        if (heavy[u]!=-1){
            decompose(heavy[u],h);
        }
        for (int& v:g[u]){
            if (par[u]==v){continue;}
            if (v==heavy[u]){continue;}
            decompose(v,v);
        }
    }
    int query(int u, int v){
        int ret = 0;
        while(head[u]!=head[v]){
            if (h[head[u]]>h[head[v]]){swap(u,v);}
            // ret = seg.query(pos[head[v]],pos[v]);
            // define ds + operation
            v = par[head[v]];
        }
        if (h[u]>h[v]){swap(u,v);}
        // ret = seg.query(pos[u]+1,pos[v]); (edge query)
        // ret = seg.query(pos[u],pos[v])l (vertex query)
        // 해당 line은 edge에 관한 query인지 vertex에 관한 query인지에 따라 다르다
        return ret;
    }
};